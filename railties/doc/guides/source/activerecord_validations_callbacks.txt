Active Record Validations and Callbacks
=======================================

This guide teaches you how to work with the lifecycle of your Active Record objects. More precisely, you will learn how to validate the state of your objects before they go into the database and also how to teach them to perform custom operations at certain points of their lifecycles.

After reading this guide and trying out the presented concepts, we hope that you'll be able to:

* Correctly use all the built-in Active Record validation helpers
* Create your own custom validation methods
* Work with the error messages generated by the validation process
* Register callback methods that will execute custom operations during your objects lifecycle, for example before/after they are saved.
* Create special classes that encapsulate common behaviour for your callbacks
* Create Observers - classes with callback methods specific for each of your models, keeping the callback code outside your models' declarations.

== Motivations to validate your Active Record objects

The main reason for validating your objects before they get into the database is to ensure that only valid data is recorded. It's important to be sure that an email address column only contains valid email addresses, or that the customer's name column will never be empty. Constraints like that keep your database organized and helps your application to work properly. 

There are several ways to validate the data that goes to the database, like using database native constraints, implementing validations only at the client side or implementing them directly into your models. Each one has pros and cons:

* Using database constraints and/or stored procedures makes the validation mechanisms database-dependent and may turn your application into a hard to test and mantain beast. However, if your database is used by other applications, it may be a good idea to use some constraints also at the database level.
* Implementing validations only at the client side can be problematic, specially with web-based applications. Usually this kind of validation is done using javascript, which may be turned off in the user's browser, leading to invalid data getting inside your database. However, if combined with server side validation, client side validation may be useful, since the user can have a faster feedback from the application when trying to save invalid data.
* Using validation directly into your Active Record classes ensures that only valid data gets recorded, while still keeping the validation code in the right place, avoiding breaking the MVC pattern. Since the validation happens on the server side, the user cannot disable it, so it's also safer. It may be a hard and tedious work to implement some of the logic involved in your models' validations, but fear not: Active Record gives you the hability to easily create validations, using several built-in helpers while still allowing you to create your own validation methods.

== How it works

=== When does validation happens?

There are two kinds of Active Record objects: those that correspond to a row inside your database and those who do not. When you create a fresh object, using the +new+ method, that object does not belong to the database yet. Once you call +save+ upon that object it'll be recorded to it's table. Active Record uses the +new_record?+ instance method to discover if an object is already in the database or not. Consider the following simple and very creative Active Record class:

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
end
------------------------------------------------------------------

We can see how it works by looking at the following script/console output:

------------------------------------------------------------------
>> p = Person.new(:name => "John Doe", :birthdate => Date.parse("09/03/1979"))
=> #<Person id: nil, name: "John Doe", birthdate: "1979-09-03", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
------------------------------------------------------------------

Saving new records means sending an SQL insert operation to the database, while saving existing records (by calling either +save+ or +update_attributes+) will result in a SQL update operation. Active Record will use these facts to perform validations upon your objects, avoiding then to be recorded to the database if their inner state is invalid in some way. You can specify validations that will be beformed every time a object is saved, just when you're creating a new record or when you're updating an existing one.

CAUTION: There are four methods that when called will trigger validation: +save+, +save!+, +update_attributes+ and +update_attributes!+. There is one method left, which is +update_attribute+. This method will update the value of an attribute without triggering any validation, so be careful when using +update_attribute+, since it can let you save your objects in an invalid state.

=== The meaning of 'valid'

For verifying if an object is valid, Active Record uses the +valid?+ method, which basically looks inside the object to see if it has any validation errors. These errors live in a collection that can be accessed through the +errors+ instance method. The proccess is really simple: If the +errors+ method returns an empty collection, the object is valid and can be saved. Each time a validation fails, an error message is added to the +errors+ collection.

== The declarative validation helpers

Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers create validations rules that are commonly used in most of the applications that you'll write, so you don't need to recreate it everytime, avoiding code duplication, keeping everything organized and boosting your productivity. Everytime a validation fails, an error message is added to the object's +errors+ collection, this message being associated with the field being validated. 

Each helper accepts an arbitrary number of attributes, received as symbols, so with a single line of code you can add the same kind of validation to several attributes.

All these helpers accept the +:on+ and +:message+ options, which define when the validation should be applied and what message should be added to the +errors+ collection when it fails, respectively. The +:on+ option takes one the values +:save+ (it's the default), +:create+  or +:update+. There is a default error message for each one of the validation helpers. These messages are used when the +:message+ option isn't used. Let's take a look at each one of the available helpers, listed in alphabetic order.

=== The +validates_acceptance_of+ helper

Validates that a checkbox has been checked for agreement purposes. It's normally used when the user needs to agree with your application's terms of service, confirm reading some clauses or any similar concept. This validation is very specific to web applications and actually this 'acceptance' does not need to be recorded anywhere in your database (if you don't have a field for it, the helper will just create a virtual attribute).

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service
end
------------------------------------------------------------------

The default error message for +validates_acceptance_of+ is "_must be accepted_"

+validates_acceptance_of+ can receive an +:accept+ option, which determines the value that will be considered acceptance. It defaults to "1", but you can change it.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service, :accept => 'yes'
end
------------------------------------------------------------------


=== The +validates_associated+ helper

You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, +valid?+ will be called upon each one of the associated objects.

[source, ruby]     
------------------------------------------------------------------
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
------------------------------------------------------------------

This validation will work with all the association types.

CAUTION: Pay attention not to use +validates_associated+ on both ends of your associations, because this will lead to several recursive calls and blow up the method calls' stack.

The default error message for +validates_associated+ is "_is invalid_". Note that the errors for each failed validation in the associated objects will be set there and not in this model.

=== The +validates_confirmation_of+ helper

You should use this helper when you have two text fields that should receive exactly the same content, like when you want to confirm an email address or password. This validation creates a virtual attribute, using the name of the field that has to be confirmed with '_confirmation' appended.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_confirmation_of :email
end
------------------------------------------------------------------

In your view template you could use something like
------------------------------------------------------------------
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
------------------------------------------------------------------

NOTE: This check is performed only if +email_confirmation+ is not nil, and by default only on save. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at +validates_presence_of+ later on this guide):

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_confirmation_of :email
  validates_presence_of :email_confirmation
end
------------------------------------------------------------------

The default error message for +validates_confirmation_of+ is "_doesn't match confirmation_"

=== The +validates_each+ helper

This helper validates attributes against a block. It doesn't have a predefined validation function. You should create one using a block, and every attribute passed to +validates_each+ will be tested against it. In the following example, we don't want names and surnames to begin with lower case.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'Must start with upper case') if value =~ /^[a-z]/
  end
end
------------------------------------------------------------------

The block receives the model, the attribute's name and the attribute's value. If your validation fails, you can add an error message to the model, therefore making it invalid.

=== The +validates_exclusion_of+ helper

This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.

[source, ruby]
------------------------------------------------------------------
class MovieFile < ActiveRecord::Base
  validates_exclusion_of :format, :in => %w(mov avi), 
    :message => "Extension %s is not allowed"
end
------------------------------------------------------------------

The +validates_exclusion_of+ helper has an option +:in+ that receives the set of values that will not be accepted for the validated attributes. The +:in+ option has an alias called +:within+  that you can use for the same purpose, if you'd like to. In the previous example we used the +:message+ option to show how we can personalize it with the current attribute's value, through the +%s+ format mask.

The default error message for +validates_exclusion_of+  is "_is not included in the list_".

=== The +validates_format_of+ helper

This helper validates the attributes's values by testing if they match a given pattern. This pattern must be specified using a Ruby regular expression, which must be passed through the +:with+ option.

[source, ruby]
------------------------------------------------------------------
class Product < ActiveRecord::Base
  validates_format_of :description, :with => /^[a-zA-Z]+$/, 
    :message => "Only letters allowed"
end
------------------------------------------------------------------

The default error message for +validates_format_of+ is "_is invalid_".

=== The +validates_inclusion_of+ helper

This helper validates that the attributes' values are included in a given set. In fact, this set can be any enumerable object.

[source, ruby]
------------------------------------------------------------------
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large), 
    :message => "%s is not a valid size"
end
------------------------------------------------------------------

The +validates_inclusion_of+ helper has an option +:in+ that receives the set of values that will be accepted. The +:in+ option has an alias called +:within+  that you can use for the same purpose, if you'd like to. In the previous example we used the +:message+ option to show how we can personalize it with the current attribute's value, through the +%s+ format mask.

The default error message for +validates_inclusion_of+  is "_is not included in the list_".

=== The +validates_length_of+ helper

This helper validates the length of your attribute's value. It can receive a variety of different options, so you can specify length contraints in different ways.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_length_of :name, :minimum => 2
  validates_length_of :bio, :maximum => 500
  validates_length_of :password, :in => 6..20
  validates_length_of :registration_number, :is => 6
end
------------------------------------------------------------------

The possible length constraint options are:

* +:minimum+ - The attribute cannot have less than the specified length.
* +:maximum+ - The attribute cannot have more than the specified length.
* +:in+ (or +:within+) - The attribute length must be included in a given interval. The value for this option must be a Ruby range. 
* +:is+ - The attribute length must be equal to a given value.

The default error messages depend on the type of length validation being performed. You can personalize these messages, using the +:wrong_length+, +:too_long+ and +:too_short+ options and the +%d+ format mask as a placeholder for the number corresponding to the length contraint being used. You can still use the +:message+ option to specify an error message.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_length_of :bio, :too_long => "you're writing too much. %d characters is the maximum allowed."
end
------------------------------------------------------------------

This helper has an alias called +validates_size_of+, it's the same helper with a different name. You can use it if you'd like to.

=== The +validates_numericality_of+ helper

This helper validates that your attributes have only numeric values. By default, it will match an optional sign followed by a integral or floating point number. Using the +:integer_only+ option set to true, you can specify that only integral numbers are allowed.

If you use +:integer_only+ set to +true+, then it will use the +$$/\A[+\-]?\d+\Z/$$+ regular expression to validate the attribute's value. Otherwise, it will try to convert the value using +Kernel.Float+.

[source, ruby]
------------------------------------------------------------------
class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, :integer_only => true
end
------------------------------------------------------------------

The default error message for +validates_numericality_of+ is "_is not a number_".

=== The +validates_presence_of+ helper

This helper validates that the attributes are not empty. It uses the +blank?+ method to check if the value is either +nil+ or an empty string (if the string has only spaces, it will still be considered empty). 

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_presence_of :name, :login, :email
end
------------------------------------------------------------------

NOTE: If you want to be sure that an association is present, you'll need to test if the foreign key used to map the association is present, and not the associated object itself.

[source, ruby]
------------------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates_presence_of :order_id
end
------------------------------------------------------------------

NOTE: If you want to validate the presence of a boolean field (where the real values are true and false), you will want to use validates_inclusion_of :field_name, :in => [true, false] This is due to the way Object#blank? handles boolean values. false.blank? # => true 

The default error message for +validates_presence_of+ is "_can't be empty_".

=== The +validates_uniqueness_of+ helper

This helper validates that the attribute's value is unique right before the object gets saved. It does not create a uniqueness constraint directly into your database, so it may happen that two different database connections create two records with the same value for a column that you wish were unique. To avoid that, you must create an unique index in your database.

[source, ruby]
------------------------------------------------------------------
class Account < ActiveRecord::Base
  validates_uniqueness_of :email
end
------------------------------------------------------------------

The validation happens by performing a SQL query into the model's table, searching for a record where the attribute that must be validated is equal to the value in the object being validated.

There is a +:scope+ option that you can use to specify other attributes that must be used to define uniqueness:

[source, ruby]
------------------------------------------------------------------
class Holiday < ActiveRecord::Base
  validates_uniqueness_of :name, :scope => :year, 
    :message => "Should happen once per year"
end
------------------------------------------------------------------

There is also a +:case_sensitive+ option that you can use to define if the uniqueness contraint will be case sensitive or not. This option defaults to true.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_uniqueness_of :name, :case_sensitive => false
end
------------------------------------------------------------------

The default error message for +validates_uniqueness_of+ is "_has already been taken_".

== Common validation options

There are some common options that all the validation helpers can use. Here they are, except for the +:if+ and +:unless+ options, which we'll cover right at the next topic.

=== The +:allow_nil+ option

You may use the +:allow_nil+ option everytime you want to trigger a validation only if the value being validated is not +nil+. You may be asking yourself if it makes any sense to use +:allow_nil+ and +validates_presence_of+ together. Well, it does. Remember, validation will be skipped only for +nil+ attributes, but empty strings are not considered +nil+.

[source, ruby]
------------------------------------------------------------------
class Coffee < ActiveRecord::Base
  validates_inclusion_of :size, :in => %w(small medium large), 
    :message => "%s is not a valid size", :allow_nil => true
end
------------------------------------------------------------------

=== The +:message+ option

As stated before, the +:message+ option lets you specify the message that will be added to the +errors+ collection when validation fails. When this option is not used, Active Record will use the respective default error message for each validation helper.

=== The +:on+ option

As stated before, the +:on+ option lets you specify when the validation should happen. The default behaviour for all the built-in validation helpers is to be ran on save (both when you're creating a new record and when you're updating it). If you want to change it, you can use +:on =$$>$$ :create+ to run the validation only when a new record is created or +:on =$$>$$ :update+ to run the validation only when a record is updated.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  # => it will be possible to update email with a duplicated value
  validates_uniqueness_of :email, :on => :create 
  
  # => it will be possible to create the record with a 'non-numerical age'
  validates_numericality_of :age, :on => :update 
  
  # => the default
  validates_presence_of :name, :on => :save 
end
------------------------------------------------------------------

== Conditional validation

Sometimes it will make sense to validate an object just when a given predicate is satisfied. You can do that by using the +:if+ and +:unless+ options, which can take a symbol, a string or a Ruby Proc. You may use the +:if+ option when you want to specify when the validation *should* happen. If you want to specify when the validation *should not* happen, then you may use the +:unless+ option.

=== Using a symbol with the +:if+ and +:unless+ options

You can associated the +:if+ and +:unless+ options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.

[source, ruby]
------------------------------------------------------------------
class Order < ActiveRecord::Base
  validates_presence_of :card_number, :if => :paid_with_card?
  
  def paid_with_card?
    payment_type == "card"
  end
end
------------------------------------------------------------------

=== Using a string with the +:if+ and +:unless+ options

You can also use a string that will be evaluated using +:eval+ and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_presence_of :surname, :if => "name.nil?"
end
------------------------------------------------------------------

=== Using a Proc object with the +:if+ and :+unless+ options

Finally, it's possible to associate +:if+ and +:unless+ with a Ruby Proc object which will be called. Using a Proc object can give you the hability to write a condition that will be executed only when the validation happens and not when your code is loaded by the Ruby interpreter. This option is best suited when writing short validation methods, usually one-liners.

[source, ruby]
------------------------------------------------------------------
class Account < ActiveRecord::Base
  validates_confirmation_of :password, 
    :unless => Proc.new { |a| a.password.blank? }
end
------------------------------------------------------------------

== Writing your own validation methods

When the built-in validation helpers are not enough for your needs, you can write your own validation methods, by implementing one or more of the +validate+, +validate_on_create+ or +validate_on_update+ methods. As the names of the methods states, the right method to implement depends on when you want the validations to be ran. The meaning of valid is still the same: to make an object invalid you just need to add a message to it's +errors+ collection.

[source, ruby]
------------------------------------------------------------------
class Invoice < ActiveRecord::Base
  def validate_on_create    
    errors.add(:expiration_date, "can't be in the past") if 
      !expiration_date.blank? and expiration_date < Date.today
  end
end
------------------------------------------------------------------

If your validation rules are too complicated and you want to break them in small methods, you can implement all of them and call one of +validate+, +validate_on_create+ or +validate_on_update+ methods, passing it the symbols for the methods' names.

[source, ruby]
------------------------------------------------------------------
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past, 
    :discount_cannot_be_more_than_total_value

  def expiration_date_cannot_be_in_the_past
    errors.add(:expiration_date, "can't be in the past") if 
      !expiration_date.blank? and expiration_date < Date.today
  end  
  
  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") unless 
      discount <= total_value
  end
end
------------------------------------------------------------------

== Using the +errors+ collection

You can do more than just call +valid?+ upon your objects based on the existance of the +errors+ collection. Here is a list of the other available methods that you can use to manipulate errors or ask for an object's state.

* +add_to_base+ lets you add errors messages that are related to the object's state as a whole, instead of being related to a specific attribute. You can use this method when you want to say that the object is invalid, no matter the values of it's attributes. +add_to_base+ receives a string with the message.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add_to_base("This person is invalid because ...")
  end
end
------------------------------------------------------------------

* +add+ lets you manually add messages that are related to particular attributes. When writing those messages, keep in mind that Rails will prepend them with the name of the attribute that holds the error, so write it in a way that makes sense. +add+ receives a symbol with the name of the attribute that you want to add the message to and the message itself.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "can't have the characters !@#$%*()_-+=")
  end
end
------------------------------------------------------------------

* +invalid?+ is used when you want to check if a particular attribute is invalid. It receives a symbol with the name of the attribute that you want to check.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_presence_of :name, :email
end

person = Person.new(:name => "John Doe")
person.invalid?(:email) # => true
------------------------------------------------------------------

* +on+ is used when you want to check the error messages for a specific attribute. It will return different kinds of objects depending on the state of the +errors+ collection for the given attribute. If there are no errors related to the attribute, +on+ will return +nil+. If there is just one errors message for this attribute, +on+ will return a string with the message. When +errors+ holds two or more error messages for the attribute, +on+ will return an array of strings, each one with one error message.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new(:name => "John Doe")
person.valid? # => true
person.errors.on(:name) # => nil

person = Person.new(:name => "JD")
person.valid? # => false
person.errors.on(:name) 
# => "is too short (minimum is 3 characters)"

person = Person.new
person.valid? # => false
person.errors.on(:name)
# => ["can't be blank", "is too short (minimum is 3 characters)"]
------------------------------------------------------------------

* +clear+ is used when you intentionally want to clear all the messages in the +errors+ collection. However, calling +errors.clear+ upon an invalid object won't make it valid: the +errors+ collection will now be empty, but the next time you call +valid?+ or any method that tries to save this object to the database, the validations will run. If any of them fails, the +errors+ collection will get filled again.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :minimum => 3
end

person = Person.new
person.valid? # => false
person.errors.on(:name) 
# => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true  
p.save # => false
p.errors.on(:name)
# => ["can't be blank", "is too short (minimum is 3 characters)"]
------------------------------------------------------------------

== Callbacks

Callbacks are methods that get called at certain moments of an object's lifecycle. With callbacks it's possible to write code that will run whenever an Active Record object is created, saved, updated, deleted or loaded from the database.

=== Callbacks registration

In order to use the available callbacks, you need to registrate them. There are two ways of doing that. 

=== Registering callbacks by overriding the callback methods

You can specify the callback method directly, by overriding it. Let's see how it works using the +before_validation+ callback, which will surprisingly run right before any validation is done.

[source, ruby]
------------------------------------------------------------------
class User < ActiveRecord::Base
  validates_presence_of :login, :email
  
  protected
  def before_validation
    if self.login.nil?
      self.login = email unless email.blank?
    end
  end
end
------------------------------------------------------------------

=== Registering callbacks by using macro-style class methods

The other way you can register a callback method is by implementing it as an ordinary method, and then using a macro-style class method to register it as a callback. The last example could be written like that:

[source, ruby]
------------------------------------------------------------------
class User < ActiveRecord::Base
  validates_presence_of :login, :email
  
  before_validation :ensure_login_has_a_value
  
  protected
  def ensure_login_has_a_value
    if self.login.nil?
      self.login = email unless email.blank?
    end
  end  
end
------------------------------------------------------------------

The macro-style class methods can also receive a block. Rails best practices say that you should only use this style of registration if the code inside your block is so short that it fits in just one line.

[source, ruby]
------------------------------------------------------------------
class User < ActiveRecord::Base
  validates_presence_of :login, :email
  
  before_create {|user| user.name = user.login.capitalize if user.name.blank?}
end
------------------------------------------------------------------

In Rails, the preferred way of registering callbacks is by using macro-style class methods. The main advantages of using macro-style class methods are:

* You can add more than one method for each type of callback. Those methods will be queued for execution at the same order they were registered.
* Readability, since your callback declarations will live at the beggining of your models' files.

CAUTION: Remember to always declare the callback methods as being protected or private. These methods should never be public, otherwise it will be possible to call them from code outside the model, violating object encapsulation and exposing implementation details.

== Available callbacks
 
Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations.

=== Callbacks called both when creating or updating a record.

* +before_validation+ 
* +after_validation+ 
* +before_save+ 
* *INSERT OR UPDATE OPERATION*
* +after_save+ 

=== Callbacks called only when creating a new record.

* +before_validation_on_create+ 
* +after_validation_on_create+ 
* +before_create+
* *INSERT OPERATION*
* +after_create+

=== Callbacks called only when updating an existing record.

* +before_validation_on_update+
* +after_validation_on_update+
* +before_update+
* *UPDATE OPERATION*
* +after_update+

=== Callbacks called when removing a record from the database.

* +before_destroy+
* *DELETE OPERATION*
* +after_destroy+

The +before_destroy+ and +after_destroy+ callbacks will only be called if you delete the model using either the +destroy+ instance method or one of the +destroy+ or +destroy_all+ class methods of your Active Record class. If you use +delete+ or +delete_all+ no callback operations will run, since Active Record will not instantiate any objects, accessing the records to be deleted directly in the database.

=== The +after_initialize+ and +after_find+ callbacks

The +after_initialize+ callback will be called whenever an Active Record object is instantiated, either by direcly using +new+ or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record +initialize+ method.

The +after_find+ callback will be called whenever Active Record loads a record from the database. When used together with +after_initialize+ it will run first, since Active Record will first read the record from the database and them create the model object that will hold it. 

The +after_initialize+ and +after_find+ callbacks are a bit different from the others, since the only way to register those callbacks is by defining them as methods. If you try to register +after_initialize+ or +after_find+ using macro-style class methods, they will just be ignored. This behaviour is due to performance reasons, since +after_initialize+ and +after_find+ will both be called for each record found in the database, significantly slowing down the queries.

== Halting Execution

As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model's validations, the registered callbacks and the database operation to be executed. However, if at any moment one of the +before_create+, +before_save+, +before_update+ or +before_destroy+ callback methods returns a boolean +false+ (not +nil+) value, this execution chain will be halted and the desired operation will not complete: your model will not get persisted in the database, or your records will not get deleted and so on.

== Callback classes

Sometimes the callback methods that you'll write will be useful enough to be reused at other models. Active Record makes it possible to create classes that encapsulate the callback methods, so it becomes very easy to reuse them.

Here's an example where we create a class with a after_destroy callback for a PictureFile model.

[source, ruby]
------------------------------------------------------------------
class PictureFileCallbacks
  def after_destroy(picture_file)
    File.delete(picture_file.filepath) if File.exists?(picture_file.filepath)
  end
end
------------------------------------------------------------------

When declared inside a class the callback method will receive the model object as a parameter. We can now use it this way:

[source, ruby]
------------------------------------------------------------------
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
------------------------------------------------------------------

Note that we needed to instantiate a new PictureFileCallbacks object, since we declared our callback as an instance method. Sometimes it will make more sense to have it as a class method.

[source, ruby]
------------------------------------------------------------------
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    File.delete(picture_file.filepath) if File.exists?(picture_file.filepath)
  end
end 
------------------------------------------------------------------

If the callback method is declared this way, it won't be necessary to instantiate a PictureFileCallbacks object.

[source, ruby]
------------------------------------------------------------------
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
------------------------------------------------------------------

You can declare as many callbacks as you want inside your callback classes.

== Observers

Active Record callbacks are a powerful feature, but they can pollute your model implementation with code that's not directly related to the model's purpose. In object-oriented software, it's always a good idea to design your classes with a single responsability in the whole system. For example, it wouldn't make much sense to have a +User+ model with a method that writes data about a login attempt to a log file. Whenever you're using callbacks to write code that's not directly related to your model class purposes, it may be a good moment to create an Observer.

An Active Record Observer is an object that links itself to a model and register it's methods for callbacks. Your model's implementation remain clean, while you can reuse the code in the Observer to add behaviuor to more than one model class. Ok, you may say that we can also do that using callback classes, but it would still force us to add code to our model's implementation.

Observer classes are subclasses of the +ActiveRecord::Observer+ class. When this class is subclassed, Active Record will look at the name of the new class and then strip the 'Observer' part to find the name of the Active Record class to observe.

Consider a +Registration+ model, where we want to send an email everytime a new registration is created. Since sending emails is not directly related to our model's purpose, we could create an Observer to do just that:

[source, ruby]
------------------------------------------------------------------
class RegistrationObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send registration confirmation emails...
  end
end
------------------------------------------------------------------

Like in callback classes, the observer's methods receive the observed model as a parameter.

Sometimes using the ModelName + Observer naming convention won't be the best choice, mainly when you want to use the same observer for more than one model class. It's possible to explicity specify the models that our observer should observe. 

[source, ruby]
------------------------------------------------------------------
class Auditor < ActiveRecord::Observer
  observe User, Registration, Invoice
end
------------------------------------------------------------------

=== Registering observers

If you payed attention, you may be wondering where Active Record Observers are referenced in our applications, so they get instantiate and begin to interact with our models. For observers to work we need to register them somewhere. The usual place to do that is in our application's *config/environment.rb* file. In this file there is a commented out line where we can define the observers that our application should load at start-up. 

[source, ruby]
------------------------------------------------------------------
# Activate observers that should always be running
config.active_record.observers = :registration_observer, :auditor
------------------------------------------------------------------

You can uncomment the line with +config.active_record.observers+ and change the symbols for the name of the observers that should be registered.

It's also possible to register callbacks in any of the files living at *config/environments/*, if you want an observer to work only in a specific environment. There is not a +config.active_record.observers+ line at any of those files, but you can simply add it.

=== Where to put the observers' source files

By convention, you should always save your observers' source files inside *app/models*.

== Changelog

http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks
