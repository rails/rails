ENV["PORT"] ||= "3000"
VERBOSE = ARGV.include?("--verbose") || ARGV.include?("-v") || ENV["VERBOSE"]
RAILS_ARGS = ARGV - ["--verbose", "-v"]
PROCFILE = "Procfile.dev"
FOREMAN_LOG = "log/foreman.log"

# Run rails standalone if no Procfile.dev exists
Process.exec(*%w[bundle exec rails server], *RAILS_ARGS) unless File.exist?(PROCFILE)

# Ignore INT so we can handle cleanup ourselves
Signal.trap("INT") { }

# Install foreman if not present
if system(*%w[gem list --no-installed --exact --silent foreman])
  puts "Installing foreman..."
  system(*%w[gem install foreman])
end

# Start foreman (background processes) and rails (foreground with logs)
begin
  foreman_stdin_r, foreman_stdin_w = IO.pipe
  foreman_log = VERBOSE ? STDOUT : File.open(FOREMAN_LOG, "a")
  foreman_pid = Process.spawn(
    *%w[foreman start -f Procfile.dev -m all=1,web=0 --env /dev/null],
    in: foreman_stdin_r,
    out: foreman_log,
    err: foreman_log,
    pgroup: true
  )
  foreman_pgid = Process.getpgid(foreman_pid)
  rails_pid = Process.spawn(*%w[bundle exec rails server], *RAILS_ARGS)

  # Wait for foreman or rails to exit (ignore other subprocesses)
  loop do
    exited_pid, = Process.wait2(-1)
    if exited_pid == foreman_pid
      foreman_pid = nil
      Process.kill("INT", rails_pid) rescue Errno::ESRCH
      $stderr.puts "\n\e[31m!! Foreman crashed !!\e[0m\nCheck #{FOREMAN_LOG} to debug or run bin/dev --verbose"
      break
    elsif exited_pid == rails_pid
      rails_pid = nil
      break
    end
  end

# Cleanup: terminate any remaining processes and close file handles
ensure
  if foreman_pid
    Process.kill("INT", -foreman_pgid)
    Process.wait(-foreman_pgid) rescue Errno::ECHILD
  end
  Process.kill("KILL", rails_pid) rescue Errno::ESRCH if rails_pid

  foreman_log.close if foreman_log.is_a?(File)
  foreman_stdin_r.close
  foreman_stdin_w.close
end
