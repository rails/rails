From f9c93bc57d2fa4af85189d5226ab3730c254f145 Mon Sep 17 00:00:00 2001
From: Richard <113485471+dsuprmajstc93r@users.noreply.github.com>
Date: Sun, 23 Oct 2022 15:29:05 -0600
Subject: [PATCH] Add files via upload

Signed-off-by: Richard <113485471+dsuprmajstc93r@users.noreply.github.com>
---
 README.md                      | 103 +----
 all.rb                         |  23 ++
 app_loader.rb                  |  77 ++++
 app_updater.rb                 |  40 ++
 application.rb                 | 617 ++++++++++++++++++++++++++++
 application_controller.rb      |  28 ++
 autoloaders.rb                 |  48 +++
 backtrace_cleaner.rb           |  27 ++
 cli.rb                         |  19 +
 code_statistics.rb             | 117 ++++++
 code_statistics_calculator.rb  |  97 +++++
 command.rb                     | 121 ++++++
 commands.rb                    |  18 +
 configuration.rb               | 161 ++++++++
 console                        |  11 +
 dev_caching.rb                 |  44 ++
 engine.rb                      | 727 +++++++++++++++++++++++++++++++++
 gem_version.rb                 |  17 +
 generators.rb                  | 331 +++++++++++++++
 info.rb                        | 105 +++++
 info_controller.rb             |  43 ++
 initializable.rb               |  95 +++++
 line_statistics                |  42 ++
 mailers_controller.rb          |  99 +++++
 paths.rb                       | 243 +++++++++++
 profile                        | 137 +++++++
 qunit-selenium-runner.rb       |  33 ++
 rack.rb                        |   7 +
 rails                          |  10 +
 rails.rb                       | 127 ++++++
 railtie.rb                     | 303 ++++++++++++++
 release.rb                     | 333 +++++++++++++++
 release_announcement_draft.erb |  45 ++
 ruby_version_check.rb          |  15 +
 secrets.rb                     | 108 +++++
 source_annotation_extractor.rb | 148 +++++++
 tasks.rb                       |  19 +
 test                           |   5 +
 test.rb                        |  18 +
 test_common.rb                 |   7 +
 test_help.rb                   |  50 +++
 test_run.rb                    |  72 ++++
 version.rb                     |  17 +-
 welcome_controller.rb          |  11 +
 44 files changed, 4611 insertions(+), 107 deletions(-)
 create mode 100644 all.rb
 create mode 100644 app_loader.rb
 create mode 100644 app_updater.rb
 create mode 100644 application.rb
 create mode 100644 application_controller.rb
 create mode 100644 autoloaders.rb
 create mode 100644 backtrace_cleaner.rb
 create mode 100644 cli.rb
 create mode 100644 code_statistics.rb
 create mode 100644 code_statistics_calculator.rb
 create mode 100644 command.rb
 create mode 100644 commands.rb
 create mode 100644 configuration.rb
 create mode 100644 console
 create mode 100644 dev_caching.rb
 create mode 100644 engine.rb
 create mode 100644 gem_version.rb
 create mode 100644 generators.rb
 create mode 100644 info.rb
 create mode 100644 info_controller.rb
 create mode 100644 initializable.rb
 create mode 100644 line_statistics
 create mode 100644 mailers_controller.rb
 create mode 100644 paths.rb
 create mode 100644 profile
 create mode 100644 qunit-selenium-runner.rb
 create mode 100644 rack.rb
 create mode 100644 rails
 create mode 100644 rails.rb
 create mode 100644 railtie.rb
 create mode 100644 release.rb
 create mode 100644 release_announcement_draft.erb
 create mode 100644 ruby_version_check.rb
 create mode 100644 secrets.rb
 create mode 100644 source_annotation_extractor.rb
 create mode 100644 tasks.rb
 create mode 100644 test
 create mode 100644 test.rb
 create mode 100644 test_common.rb
 create mode 100644 test_help.rb
 create mode 100644 test_run.rb
 create mode 100644 welcome_controller.rb

diff --git a/README.md b/README.md
index 019ba3a41e080..f133b27128d78 100644
--- a/README.md
+++ b/README.md
@@ -1,97 +1,10 @@
-# Welcome to Rails
+# Rails dev tools
 
-## What's Rails?
+This is a collection of utilities used for Rails internal development.
+They aren't used by Rails apps directly.
 
-Rails is a web-application framework that includes everything needed to
-create database-backed web applications according to the
-[Model-View-Controller (MVC)](https://en.wikipedia.org/wiki/Model-view-controller)
-pattern.
-
-Understanding the MVC pattern is key to understanding Rails. MVC divides your
-application into three layers: Model, View, and Controller, each with a specific responsibility.
-
-## Model layer
-
-The _**Model layer**_ represents the domain model (such as Account, Product,
-Person, Post, etc.) and encapsulates the business logic specific to
-your application. In Rails, database-backed model classes are derived from
-`ActiveRecord::Base`. [Active Record](activerecord/README.rdoc) allows you to present the data from
-database rows as objects and embellish these data objects with business logic
-methods.
-Although most Rails models are backed by a database, models can also be ordinary
-Ruby classes, or Ruby classes that implement a set of interfaces as provided by
-the [Active Model](activemodel/README.rdoc) module.
-
-## View layer
-
-The _**View layer**_ is composed of "templates" that are responsible for providing
-appropriate representations of your application's resources. Templates can
-come in a variety of formats, but most view templates are HTML with embedded
-Ruby code (ERB files). Views are typically rendered to generate a controller response
-or to generate the body of an email. In Rails, View generation is handled by [Action View](actionview/README.rdoc).
-
-## Controller layer
-
-The _**Controller layer**_ is responsible for handling incoming HTTP requests and
-providing a suitable response. Usually, this means returning HTML, but Rails controllers
-can also generate XML, JSON, PDFs, mobile-specific views, and more. Controllers load and
-manipulate models, and render view templates in order to generate the appropriate HTTP response.
-In Rails, incoming requests are routed by Action Dispatch to an appropriate controller, and
-controller classes are derived from `ActionController::Base`. Action Dispatch and Action Controller
-are bundled together in [Action Pack](actionpack/README.rdoc).
-
-## Frameworks and libraries
-
-[Active Record](activerecord/README.rdoc), [Active Model](activemodel/README.rdoc), [Action Pack](actionpack/README.rdoc), and [Action View](actionview/README.rdoc) can each be used independently outside Rails.
-
-In addition to that, Rails also comes with:
-
-- [Action Mailer](actionmailer/README.rdoc), a library to generate and send emails
-- [Action Mailbox](actionmailbox/README.md), a library to receive emails within a Rails application
-- [Active Job](activejob/README.md), a framework for declaring jobs and making them run on a variety of queuing backends
-- [Action Cable](actioncable/README.md), a framework to integrate WebSockets with a Rails application
-- [Active Storage](activestorage/README.md), a library to attach cloud and local files to Rails applications
-- [Action Text](actiontext/README.md), a library to handle rich text content
-- [Active Support](activesupport/README.rdoc), a collection of utility classes and standard library extensions that are useful for Rails, and may also be used independently outside Rails
-
-## Getting Started
-
-1. Install Rails at the command prompt if you haven't yet:
-
-        $ gem install rails
-
-2. At the command prompt, create a new Rails application:
-
-        $ rails new myapp
-
-   where "myapp" is the application name.
-
-3. Change directory to `myapp` and start the web server:
-
-        $ cd myapp
-        $ bin/rails server
-
-   Run with `--help` or `-h` for options.
-
-4. Go to `http://localhost:3000` and you'll see the Rails bootscreen with your Rails and Ruby versions.
-
-5. Follow the guidelines to start developing your application. You may find
-   the following resources handy:
-    * [Getting Started with Rails](https://guides.rubyonrails.org/getting_started.html)
-    * [Ruby on Rails Guides](https://guides.rubyonrails.org)
-    * [The API Documentation](https://api.rubyonrails.org)
-
-## Contributing
-
-We encourage you to contribute to Ruby on Rails! Please check out the
-[Contributing to Ruby on Rails guide](https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html) for guidelines about how to proceed. [Join us!](https://contributors.rubyonrails.org)
-
-Trying to report a possible security vulnerability in Rails? Please
-check out our [security policy](https://rubyonrails.org/security) for
-guidelines about how to proceed.
-
-Everyone interacting in Rails and its sub-projects' codebases, issue trackers, chat rooms, and mailing lists is expected to follow the Rails [code of conduct](https://rubyonrails.org/conduct).
-
-## License
-
-Ruby on Rails is released under the [MIT License](https://opensource.org/licenses/MIT).
+  * `console` drops you in irb and loads local Rails repos
+  * `profile` profiles `Kernel#require` to help reduce startup time
+  * `line_statistics` provides CodeTools module and LineStatistics class to count lines
+  * `test` is loaded by every major component of Rails to simplify testing, for example:
+    `cd ./actioncable; bin/test ./path/to/actioncable_test_with_line_number.rb:5`
diff --git a/all.rb b/all.rb
new file mode 100644
index 0000000000000..e620dae1bf792
--- /dev/null
+++ b/all.rb
@@ -0,0 +1,23 @@
+# frozen_string_literal: true
+
+# rubocop:disable Style/RedundantBegin
+
+require "rails"
+
+%w(
+  active_record/railtie
+  active_storage/engine
+  action_controller/railtie
+  action_view/railtie
+  action_mailer/railtie
+  active_job/railtie
+  action_cable/engine
+  action_mailbox/engine
+  action_text/engine
+  rails/test_unit/railtie
+).each do |railtie|
+  begin
+    require railtie
+  rescue LoadError
+  end
+end
diff --git a/app_loader.rb b/app_loader.rb
new file mode 100644
index 0000000000000..cc057a407dba6
--- /dev/null
+++ b/app_loader.rb
@@ -0,0 +1,77 @@
+# frozen_string_literal: true
+
+require "pathname"
+require "rails/version"
+
+module Rails
+  module AppLoader # :nodoc:
+    extend self
+
+    RUBY = Gem.ruby
+    EXECUTABLES = ["bin/rails", "script/rails"]
+    BUNDLER_WARNING = <<EOS
+Beginning in Rails 4, Rails ships with a `rails` binstub at ./bin/rails that
+should be used instead of the Bundler-generated `rails` binstub.
+
+If you are seeing this message, your binstub at ./bin/rails was generated by
+Bundler instead of Rails.
+
+You might need to regenerate your `rails` binstub locally and add it to source
+control:
+
+ rails app:update:bin           # Bear in mind this generates other binstubs
+                                # too that you may or may not want (like yarn)
+
+If you already have Rails binstubs in source control, you might be
+inadvertently overwriting them during deployment by using bundle install
+with the --binstubs option.
+
+If your application was created prior to Rails 4, here's how to upgrade:
+
+  bundle config --delete bin    # Turn off Bundler's stub generator
+  rails app:update:bin          # Use the new Rails executables
+  git add bin                   # Add bin/ to source control
+
+You may need to remove bin/ from your .gitignore as well.
+
+When you install a gem whose executable you want to use in your app,
+generate it and add it to source control:
+
+  bundle binstubs some-gem-name
+  git add bin/new-executable
+
+EOS
+
+    def exec_app
+      original_cwd = Dir.pwd
+
+      loop do
+        if exe = find_executable
+          contents = File.read(exe)
+
+          if /(APP|ENGINE)_PATH/.match?(contents)
+            exec RUBY, exe, *ARGV
+            break # non reachable, hack to be able to stub exec in the test suite
+          elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
+            $stderr.puts(BUNDLER_WARNING)
+            Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
+            require File.expand_path("../boot", APP_PATH)
+            require "rails/commands"
+            break
+          end
+        end
+
+        # If we exhaust the search there is no executable, this could be a
+        # call to generate a new application, so restore the original cwd.
+        Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?
+
+        # Otherwise keep moving upwards in search of an executable.
+        Dir.chdir("..")
+      end
+    end
+
+    def find_executable
+      EXECUTABLES.find { |exe| File.file?(exe) }
+    end
+  end
+end
diff --git a/app_updater.rb b/app_updater.rb
new file mode 100644
index 0000000000000..6e69689010ff7
--- /dev/null
+++ b/app_updater.rb
@@ -0,0 +1,40 @@
+# frozen_string_literal: true
+
+require "rails/generators"
+require "rails/generators/rails/app/app_generator"
+
+module Rails
+  class AppUpdater # :nodoc:
+    class << self
+      def invoke_from_app_generator(method)
+        app_generator.send(method)
+      end
+
+      def app_generator
+        @app_generator ||= begin
+          gen = Rails::Generators::AppGenerator.new ["rails"], generator_options, destination_root: Rails.root
+          gen.send(:valid_const?) unless File.exist?(Rails.root.join("config", "application.rb"))
+          gen
+        end
+      end
+
+      private
+        def generator_options
+          options = { api: !!Rails.application.config.api_only, update: true }
+          options[:skip_active_job]     = !defined?(ActiveJob::Railtie)
+          options[:skip_active_record]  = !defined?(ActiveRecord::Railtie)
+          options[:skip_active_storage] = !defined?(ActiveStorage::Engine)
+          options[:skip_action_mailer]  = !defined?(ActionMailer::Railtie)
+          options[:skip_action_mailbox] = !defined?(ActionMailbox::Engine)
+          options[:skip_action_text]    = !defined?(ActionText::Engine)
+          options[:skip_action_cable]   = !defined?(ActionCable::Engine)
+          options[:skip_test]           = !defined?(Rails::TestUnitRailtie)
+          options[:skip_system_test]    = Rails.application.config.generators.system_tests.nil?
+          options[:skip_asset_pipeline] = !defined?(Sprockets::Railtie) && !defined?(Propshaft::Railtie)
+          options[:skip_bootsnap]       = !defined?(Bootsnap)
+          options[:updating]            = true
+          options
+        end
+    end
+  end
+end
diff --git a/application.rb b/application.rb
new file mode 100644
index 0000000000000..137044ce071af
--- /dev/null
+++ b/application.rb
@@ -0,0 +1,617 @@
+# frozen_string_literal: true
+
+require "yaml"
+require "active_support/core_ext/hash/keys"
+require "active_support/core_ext/object/blank"
+require "active_support/key_generator"
+require "active_support/message_verifier"
+require "active_support/encrypted_configuration"
+require "active_support/hash_with_indifferent_access"
+require "active_support/configuration_file"
+require "rails/engine"
+require "rails/secrets"
+require "rails/autoloaders"
+
+module Rails
+  # An Engine with the responsibility of coordinating the whole boot process.
+  #
+  # == Initialization
+  #
+  # Rails::Application is responsible for executing all railties and engines
+  # initializers. It also executes some bootstrap initializers (check
+  # Rails::Application::Bootstrap) and finishing initializers, after all the others
+  # are executed (check Rails::Application::Finisher).
+  #
+  # == \Configuration
+  #
+  # Besides providing the same configuration as Rails::Engine and Rails::Railtie,
+  # the application object has several specific configurations, for example
+  # +cache_classes+, +consider_all_requests_local+, +filter_parameters+,
+  # +logger+, and so forth.
+  #
+  # Check Rails::Application::Configuration to see them all.
+  #
+  # == Routes
+  #
+  # The application object is also responsible for holding the routes and reloading routes
+  # whenever the files change in development.
+  #
+  # == Middlewares
+  #
+  # The Application is also responsible for building the middleware stack.
+  #
+  # == Booting process
+  #
+  # The application is also responsible for setting up and executing the booting
+  # process. From the moment you require <tt>config/application.rb</tt> in your app,
+  # the booting process goes like this:
+  #
+  # 1.  <tt>require "config/boot.rb"</tt> to set up load paths.
+  # 2.  +require+ railties and engines.
+  # 3.  Define +Rails.application+ as <tt>class MyApp::Application < Rails::Application</tt>.
+  # 4.  Run +config.before_configuration+ callbacks.
+  # 5.  Load <tt>config/environments/ENV.rb</tt>.
+  # 6.  Run +config.before_initialize+ callbacks.
+  # 7.  Run <tt>Railtie#initializer</tt> defined by railties, engines, and application.
+  #     One by one, each engine sets up its load paths and routes, and runs its <tt>config/initializers/*</tt> files.
+  # 8.  Custom <tt>Railtie#initializers</tt> added by railties, engines, and applications are executed.
+  # 9.  Build the middleware stack and run +to_prepare+ callbacks.
+  # 10. Run +config.before_eager_load+ and +eager_load!+ if +eager_load+ is +true+.
+  # 11. Run +config.after_initialize+ callbacks.
+  class Application < Engine
+    autoload :Bootstrap,              "rails/application/bootstrap"
+    autoload :Configuration,          "rails/application/configuration"
+    autoload :DefaultMiddlewareStack, "rails/application/default_middleware_stack"
+    autoload :Finisher,               "rails/application/finisher"
+    autoload :Railties,               "rails/engine/railties"
+    autoload :RoutesReloader,         "rails/application/routes_reloader"
+
+    class << self
+      def inherited(base)
+        super
+        Rails.app_class = base
+        add_lib_to_load_path!(find_root(base.called_from))
+        ActiveSupport.run_load_hooks(:before_configuration, base)
+      end
+
+      def instance
+        super.run_load_hooks!
+      end
+
+      def create(initial_variable_values = {}, &block)
+        new(initial_variable_values, &block).run_load_hooks!
+      end
+
+      def find_root(from)
+        find_root_with_flag "config.ru", from, Dir.pwd
+      end
+
+      # Makes the +new+ method public.
+      #
+      # Note that Rails::Application inherits from Rails::Engine, which
+      # inherits from Rails::Railtie and the +new+ method on Rails::Railtie is
+      # private
+      public :new
+    end
+
+    attr_accessor :assets, :sandbox
+    alias_method :sandbox?, :sandbox
+    attr_reader :reloaders, :reloader, :executor, :autoloaders
+
+    delegate :default_url_options, :default_url_options=, to: :routes
+
+    INITIAL_VARIABLES = [:config, :railties, :routes_reloader, :reloaders,
+                         :routes, :helpers, :app_env_config, :secrets] # :nodoc:
+
+    def initialize(initial_variable_values = {}, &block)
+      super()
+      @initialized       = false
+      @reloaders         = []
+      @routes_reloader   = nil
+      @app_env_config    = nil
+      @ordered_railties  = nil
+      @railties          = nil
+      @message_verifiers = {}
+      @ran_load_hooks    = false
+
+      @executor          = Class.new(ActiveSupport::Executor)
+      @reloader          = Class.new(ActiveSupport::Reloader)
+      @reloader.executor = @executor
+
+      @autoloaders = Rails::Autoloaders.new
+
+      # are these actually used?
+      @initial_variable_values = initial_variable_values
+      @block = block
+    end
+
+    # Returns true if the application is initialized.
+    def initialized?
+      @initialized
+    end
+
+    def run_load_hooks! # :nodoc:
+      return self if @ran_load_hooks
+      @ran_load_hooks = true
+
+      @initial_variable_values.each do |variable_name, value|
+        if INITIAL_VARIABLES.include?(variable_name)
+          instance_variable_set("@#{variable_name}", value)
+        end
+      end
+
+      instance_eval(&@block) if @block
+      self
+    end
+
+    # Reload application routes regardless if they changed or not.
+    def reload_routes!
+      routes_reloader.reload!
+    end
+
+    # Returns the application's KeyGenerator
+    def key_generator
+      # number of iterations selected based on consultation with the google security
+      # team. Details at https://github.com/rails/rails/pull/6952#issuecomment-7661220
+      @caching_key_generator ||= ActiveSupport::CachingKeyGenerator.new(
+        ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000)
+      )
+    end
+
+    # Returns a message verifier object.
+    #
+    # This verifier can be used to generate and verify signed messages in the application.
+    #
+    # It is recommended not to use the same verifier for different things, so you can get different
+    # verifiers passing the +verifier_name+ argument.
+    #
+    # ==== Parameters
+    #
+    # * +verifier_name+ - the name of the message verifier.
+    #
+    # ==== Examples
+    #
+    #     message = Rails.application.message_verifier('sensitive_data').generate('my sensible data')
+    #     Rails.application.message_verifier('sensitive_data').verify(message)
+    #     # => 'my sensible data'
+    #
+    # See the ActiveSupport::MessageVerifier documentation for more information.
+    def message_verifier(verifier_name)
+      @message_verifiers[verifier_name] ||= begin
+        secret = key_generator.generate_key(verifier_name.to_s)
+        ActiveSupport::MessageVerifier.new(secret)
+      end
+    end
+
+    # Convenience for loading config/foo.yml for the current Rails env.
+    #
+    # Examples:
+    #
+    #     # config/exception_notification.yml:
+    #     production:
+    #       url: http://127.0.0.1:8080
+    #       namespace: my_app_production
+    #
+    #     development:
+    #       url: http://localhost:3001
+    #       namespace: my_app_development
+    #
+    #     # config/environments/production.rb
+    #     Rails.application.configure do
+    #       config.middleware.use ExceptionNotifier, config_for(:exception_notification)
+    #     end
+    #
+    #     # You can also store configurations in a shared section which will be
+    #     # merged with the environment configuration
+    #
+    #     # config/example.yml
+    #     shared:
+    #       foo:
+    #         bar:
+    #           baz: 1
+    #
+    #     development:
+    #       foo:
+    #         bar:
+    #           qux: 2
+    #
+    #     # development environment
+    #     Rails.application.config_for(:example)[:foo][:bar]
+    #     # => { baz: 1, qux: 2 }
+    def config_for(name, env: Rails.env)
+      yaml = name.is_a?(Pathname) ? name : Pathname.new("#{paths["config"].existent.first}/#{name}.yml")
+
+      if yaml.exist?
+        require "erb"
+        all_configs    = ActiveSupport::ConfigurationFile.parse(yaml).deep_symbolize_keys
+        config, shared = all_configs[env.to_sym], all_configs[:shared]
+
+        if shared
+          config = {} if config.nil? && shared.is_a?(Hash)
+          if config.is_a?(Hash) && shared.is_a?(Hash)
+            config = shared.deep_merge(config)
+          elsif config.nil?
+            config = shared
+          end
+        end
+
+        if config.is_a?(Hash)
+          config = ActiveSupport::OrderedOptions.new.update(config)
+        end
+
+        config
+      else
+        raise "Could not load configuration. No such file - #{yaml}"
+      end
+    end
+
+    # Stores some of the Rails initial environment parameters which
+    # will be used by middlewares and engines to configure themselves.
+    def env_config
+      @app_env_config ||= super.merge(
+          "action_dispatch.parameter_filter" => config.filter_parameters,
+          "action_dispatch.redirect_filter" => config.filter_redirect,
+          "action_dispatch.secret_key_base" => secret_key_base,
+          "action_dispatch.show_exceptions" => config.action_dispatch.show_exceptions,
+          "action_dispatch.show_detailed_exceptions" => config.consider_all_requests_local,
+          "action_dispatch.log_rescued_responses" => config.action_dispatch.log_rescued_responses,
+          "action_dispatch.logger" => Rails.logger,
+          "action_dispatch.backtrace_cleaner" => Rails.backtrace_cleaner,
+          "action_dispatch.key_generator" => key_generator,
+          "action_dispatch.http_auth_salt" => config.action_dispatch.http_auth_salt,
+          "action_dispatch.signed_cookie_salt" => config.action_dispatch.signed_cookie_salt,
+          "action_dispatch.encrypted_cookie_salt" => config.action_dispatch.encrypted_cookie_salt,
+          "action_dispatch.encrypted_signed_cookie_salt" => config.action_dispatch.encrypted_signed_cookie_salt,
+          "action_dispatch.authenticated_encrypted_cookie_salt" => config.action_dispatch.authenticated_encrypted_cookie_salt,
+          "action_dispatch.use_authenticated_cookie_encryption" => config.action_dispatch.use_authenticated_cookie_encryption,
+          "action_dispatch.encrypted_cookie_cipher" => config.action_dispatch.encrypted_cookie_cipher,
+          "action_dispatch.signed_cookie_digest" => config.action_dispatch.signed_cookie_digest,
+          "action_dispatch.cookies_serializer" => config.action_dispatch.cookies_serializer,
+          "action_dispatch.cookies_digest" => config.action_dispatch.cookies_digest,
+          "action_dispatch.cookies_rotations" => config.action_dispatch.cookies_rotations,
+          "action_dispatch.cookies_same_site_protection" => coerce_same_site_protection(config.action_dispatch.cookies_same_site_protection),
+          "action_dispatch.use_cookies_with_metadata" => config.action_dispatch.use_cookies_with_metadata,
+          "action_dispatch.content_security_policy" => config.content_security_policy,
+          "action_dispatch.content_security_policy_report_only" => config.content_security_policy_report_only,
+          "action_dispatch.content_security_policy_nonce_generator" => config.content_security_policy_nonce_generator,
+          "action_dispatch.content_security_policy_nonce_directives" => config.content_security_policy_nonce_directives,
+          "action_dispatch.permissions_policy" => config.permissions_policy,
+        )
+    end
+
+    # If you try to define a set of Rake tasks on the instance, these will get
+    # passed up to the Rake tasks defined on the application's class.
+    def rake_tasks(&block)
+      self.class.rake_tasks(&block)
+    end
+
+    # Sends the initializers to the +initializer+ method defined in the
+    # Rails::Initializable module. Each Rails::Application class has its own
+    # set of initializers, as defined by the Initializable module.
+    def initializer(name, opts = {}, &block)
+      self.class.initializer(name, opts, &block)
+    end
+
+    # Sends any runner called in the instance of a new application up
+    # to the +runner+ method defined in Rails::Railtie.
+    def runner(&blk)
+      self.class.runner(&blk)
+    end
+
+    # Sends any console called in the instance of a new application up
+    # to the +console+ method defined in Rails::Railtie.
+    def console(&blk)
+      self.class.console(&blk)
+    end
+
+    # Sends any generators called in the instance of a new application up
+    # to the +generators+ method defined in Rails::Railtie.
+    def generators(&blk)
+      self.class.generators(&blk)
+    end
+
+    # Sends any server called in the instance of a new application up
+    # to the +server+ method defined in Rails::Railtie.
+    def server(&blk)
+      self.class.server(&blk)
+    end
+
+    # Sends the +isolate_namespace+ method up to the class method.
+    def isolate_namespace(mod)
+      self.class.isolate_namespace(mod)
+    end
+
+    ## Rails internal API
+
+    # This method is called just after an application inherits from Rails::Application,
+    # allowing the developer to load classes in lib and use them during application
+    # configuration.
+    #
+    #   class MyApplication < Rails::Application
+    #     require "my_backend" # in lib/my_backend
+    #     config.i18n.backend = MyBackend
+    #   end
+    #
+    # Notice this method takes into consideration the default root path. So if you
+    # are changing config.root inside your application definition or having a custom
+    # Rails application, you will need to add lib to $LOAD_PATH on your own in case
+    # you need to load files in lib/ during the application configuration as well.
+    def self.add_lib_to_load_path!(root) # :nodoc:
+      path = File.join root, "lib"
+      if File.exist?(path) && !$LOAD_PATH.include?(path)
+        $LOAD_PATH.unshift(path)
+      end
+    end
+
+    def require_environment! # :nodoc:
+      environment = paths["config/environment"].existent.first
+      require environment if environment
+    end
+
+    def routes_reloader # :nodoc:
+      @routes_reloader ||= RoutesReloader.new
+    end
+
+    # Returns an array of file paths appended with a hash of
+    # directories-extensions suitable for ActiveSupport::FileUpdateChecker
+    # API.
+    def watchable_args # :nodoc:
+      files, dirs = config.watchable_files.dup, config.watchable_dirs.dup
+
+      ActiveSupport::Dependencies.autoload_paths.each do |path|
+        File.file?(path) ? files << path.to_s : dirs[path.to_s] = [:rb]
+      end
+
+      [files, dirs]
+    end
+
+    # Initialize the application passing the given group. By default, the
+    # group is :default
+    def initialize!(group = :default) # :nodoc:
+      raise "Application has been already initialized." if @initialized
+      run_initializers(group, self)
+      @initialized = true
+      self
+    end
+
+    def initializers # :nodoc:
+      Bootstrap.initializers_for(self) +
+      railties_initializers(super) +
+      Finisher.initializers_for(self)
+    end
+
+    def config # :nodoc:
+      @config ||= Application::Configuration.new(self.class.find_root(self.class.called_from))
+    end
+
+    attr_writer :config
+
+    def secrets
+      @secrets ||= begin
+        secrets = ActiveSupport::OrderedOptions.new
+        files = config.paths["config/secrets"].existent
+        files = files.reject { |path| path.end_with?(".enc") } unless config.read_encrypted_secrets
+        secrets.merge! Rails::Secrets.parse(files, env: Rails.env)
+
+        # Fallback to config.secret_key_base if secrets.secret_key_base isn't set
+        secrets.secret_key_base ||= config.secret_key_base
+
+        secrets
+      end
+    end
+
+    attr_writer :secrets, :credentials
+
+    # The secret_key_base is used as the input secret to the application's key generator, which in turn
+    # is used to create all ActiveSupport::MessageVerifier and ActiveSupport::MessageEncryptor instances,
+    # including the ones that sign and encrypt cookies.
+    #
+    # In development and test, this is randomly generated and stored in a
+    # temporary file in <tt>tmp/development_secret.txt</tt>.
+    #
+    # In all other environments, we look for it first in <tt>ENV["SECRET_KEY_BASE"]</tt>,
+    # then +credentials.secret_key_base+, and finally +secrets.secret_key_base+. For most applications,
+    # the correct place to store it is in the encrypted credentials file.
+    def secret_key_base
+      if Rails.env.development? || Rails.env.test?
+        secrets.secret_key_base ||= generate_development_secret
+      else
+        validate_secret_key_base(
+          ENV["SECRET_KEY_BASE"] || credentials.secret_key_base || secrets.secret_key_base
+        )
+      end
+    end
+
+    # Decrypts the credentials hash as kept in +config/credentials.yml.enc+. This file is encrypted with
+    # the Rails master key, which is either taken from <tt>ENV["RAILS_MASTER_KEY"]</tt> or from loading
+    # +config/master.key+.
+    # If specific credentials file exists for current environment, it takes precedence, thus for +production+
+    # environment look first for +config/credentials/production.yml.enc+ with master key taken
+    # from <tt>ENV["RAILS_MASTER_KEY"]</tt> or from loading +config/credentials/production.key+.
+    # Default behavior can be overwritten by setting +config.credentials.content_path+ and +config.credentials.key_path+.
+    def credentials
+      @credentials ||= encrypted(config.credentials.content_path, key_path: config.credentials.key_path)
+    end
+
+    # Shorthand to decrypt any encrypted configurations or files.
+    #
+    # For any file added with <tt>rails encrypted:edit</tt> call +read+ to decrypt
+    # the file with the master key.
+    # The master key is either stored in +config/master.key+ or <tt>ENV["RAILS_MASTER_KEY"]</tt>.
+    #
+    #   Rails.application.encrypted("config/mystery_man.txt.enc").read
+    #   # => "We've met before, haven't we?"
+    #
+    # It's also possible to interpret encrypted YAML files with +config+.
+    #
+    #   Rails.application.encrypted("config/credentials.yml.enc").config
+    #   # => { next_guys_line: "I don't think so. Where was it you think we met?" }
+    #
+    # Any top-level configs are also accessible directly on the return value:
+    #
+    #   Rails.application.encrypted("config/credentials.yml.enc").next_guys_line
+    #   # => "I don't think so. Where was it you think we met?"
+    #
+    # The files or configs can also be encrypted with a custom key. To decrypt with
+    # a key in the +ENV+, use:
+    #
+    #   Rails.application.encrypted("config/special_tokens.yml.enc", env_key: "SPECIAL_TOKENS")
+    #
+    # Or to decrypt with a file, that should be version control ignored, relative to +Rails.root+:
+    #
+    #   Rails.application.encrypted("config/special_tokens.yml.enc", key_path: "config/special_tokens.key")
+    def encrypted(path, key_path: "config/master.key", env_key: "RAILS_MASTER_KEY")
+      ActiveSupport::EncryptedConfiguration.new(
+        config_path: Rails.root.join(path),
+        key_path: Rails.root.join(key_path),
+        env_key: env_key,
+        raise_if_missing_key: config.require_master_key
+      )
+    end
+
+    def to_app # :nodoc:
+      self
+    end
+
+    def helpers_paths # :nodoc:
+      config.helpers_paths
+    end
+
+    console do
+      unless ::Kernel.private_method_defined?(:y)
+        require "psych/y"
+      end
+    end
+
+    # Return an array of railties respecting the order they're loaded
+    # and the order specified by the +railties_order+ config.
+    #
+    # While running initializers we need engines in reverse order here when
+    # copying migrations from railties ; we need them in the order given by
+    # +railties_order+.
+    def migration_railties # :nodoc:
+      ordered_railties.flatten - [self]
+    end
+
+    # Eager loads the application code.
+    def eager_load!
+      Rails.autoloaders.each(&:eager_load)
+    end
+
+  protected
+    alias :build_middleware_stack :app
+
+    def run_tasks_blocks(app) # :nodoc:
+      railties.each { |r| r.run_tasks_blocks(app) }
+      super
+      load "rails/tasks.rb"
+      task :environment do
+        ActiveSupport.on_load(:before_initialize) { config.eager_load = config.rake_eager_load }
+
+        require_environment!
+      end
+    end
+
+    def run_generators_blocks(app) # :nodoc:
+      railties.each { |r| r.run_generators_blocks(app) }
+      super
+    end
+
+    def run_runner_blocks(app) # :nodoc:
+      railties.each { |r| r.run_runner_blocks(app) }
+      super
+    end
+
+    def run_console_blocks(app) # :nodoc:
+      railties.each { |r| r.run_console_blocks(app) }
+      super
+    end
+
+    def run_server_blocks(app) # :nodoc:
+      railties.each { |r| r.run_server_blocks(app) }
+      super
+    end
+
+    # Returns the ordered railties for this application considering railties_order.
+    def ordered_railties # :nodoc:
+      @ordered_railties ||= begin
+        order = config.railties_order.map do |railtie|
+          if railtie == :main_app
+            self
+          elsif railtie.respond_to?(:instance)
+            railtie.instance
+          else
+            railtie
+          end
+        end
+
+        all = (railties - order)
+        all.push(self)   unless (all + order).include?(self)
+        order.push(:all) unless order.include?(:all)
+
+        index = order.index(:all)
+        order[index] = all
+        order
+      end
+    end
+
+    def railties_initializers(current) # :nodoc:
+      initializers = []
+      ordered_railties.reverse.flatten.each do |r|
+        if r == self
+          initializers += current
+        else
+          initializers += r.initializers
+        end
+      end
+      initializers
+    end
+
+    def default_middleware_stack # :nodoc:
+      default_stack = DefaultMiddlewareStack.new(self, config, paths)
+      default_stack.build_stack
+    end
+
+    def validate_secret_key_base(secret_key_base)
+      if secret_key_base.is_a?(String) && secret_key_base.present?
+        secret_key_base
+      elsif secret_key_base
+        raise ArgumentError, "`secret_key_base` for #{Rails.env} environment must be a type of String`"
+      else
+        raise ArgumentError, "Missing `secret_key_base` for '#{Rails.env}' environment, set this string with `bin/rails credentials:edit`"
+      end
+    end
+
+    private
+      def generate_development_secret
+        if secrets.secret_key_base.nil?
+          key_file = Rails.root.join("tmp/development_secret.txt")
+
+          if !File.exist?(key_file)
+            random_key = SecureRandom.hex(64)
+            FileUtils.mkdir_p(key_file.dirname)
+            File.binwrite(key_file, random_key)
+          end
+
+          secrets.secret_key_base = File.binread(key_file)
+        end
+
+        secrets.secret_key_base
+      end
+
+      def build_request(env)
+        req = super
+        env["ORIGINAL_FULLPATH"] = req.fullpath
+        env["ORIGINAL_SCRIPT_NAME"] = req.script_name
+        req
+      end
+
+      def build_middleware
+        config.app_middleware + super
+      end
+
+      def coerce_same_site_protection(protection)
+        protection.respond_to?(:call) ? protection : proc { protection }
+      end
+  end
+end
diff --git a/application_controller.rb b/application_controller.rb
new file mode 100644
index 0000000000000..ac698ed91dfbb
--- /dev/null
+++ b/application_controller.rb
@@ -0,0 +1,28 @@
+# frozen_string_literal: true
+
+class Rails::ApplicationController < ActionController::Base # :nodoc:
+  self.view_paths = File.expand_path("templates", __dir__)
+  layout "application"
+
+  before_action :disable_content_security_policy_nonce!
+
+  content_security_policy do |policy|
+    policy.script_src :self, :unsafe_inline
+    policy.style_src :self, :unsafe_inline
+  end
+
+  private
+    def require_local!
+      unless local_request?
+        render html: "<p>For security purposes, this information is only available to local requests.</p>".html_safe, status: :forbidden
+      end
+    end
+
+    def local_request?
+      Rails.application.config.consider_all_requests_local || request.local?
+    end
+
+    def disable_content_security_policy_nonce!
+      request.content_security_policy_nonce_generator = nil
+    end
+end
diff --git a/autoloaders.rb b/autoloaders.rb
new file mode 100644
index 0000000000000..1aba548d1d781
--- /dev/null
+++ b/autoloaders.rb
@@ -0,0 +1,48 @@
+# frozen_string_literal: true
+
+module Rails
+  class Autoloaders # :nodoc:
+    require_relative "autoloaders/inflector"
+
+    include Enumerable
+
+    attr_reader :main, :once
+
+    def initialize
+      # This `require` delays loading the library on purpose.
+      #
+      # In Rails 7.0.0, railties/lib/rails.rb loaded Zeitwerk as a side-effect,
+      # but a couple of edge cases related to Bundler and Bootsnap showed up.
+      # They had to do with order of decoration of `Kernel#require`, something
+      # the three of them do.
+      #
+      # Delaying this `require` up to this point is a convenient trade-off.
+      require "zeitwerk"
+
+      @main = Zeitwerk::Loader.new
+      @main.tag = "rails.main"
+      @main.inflector = Inflector
+
+      @once = Zeitwerk::Loader.new
+      @once.tag = "rails.once"
+      @once.inflector = Inflector
+    end
+
+    def each
+      yield main
+      yield once
+    end
+
+    def logger=(logger)
+      each { |loader| loader.logger = logger }
+    end
+
+    def log!
+      each(&:log!)
+    end
+
+    def zeitwerk_enabled?
+      true
+    end
+  end
+end
diff --git a/backtrace_cleaner.rb b/backtrace_cleaner.rb
new file mode 100644
index 0000000000000..adf23556ee453
--- /dev/null
+++ b/backtrace_cleaner.rb
@@ -0,0 +1,27 @@
+# frozen_string_literal: true
+
+require "active_support/backtrace_cleaner"
+require "active_support/core_ext/string/access"
+
+module Rails
+  class BacktraceCleaner < ActiveSupport::BacktraceCleaner
+    APP_DIRS_PATTERN = /\A(?:\.\/)?(?:app|config|lib|test|\(\w*\))/
+    RENDER_TEMPLATE_PATTERN = /:in `.*_\w+_{2,3}\d+_\d+'/
+
+    def initialize
+      super
+      @root = "#{Rails.root}/"
+      add_filter do |line|
+        line.start_with?(@root) ? line.from(@root.size) : line
+      end
+      add_filter do |line|
+        if RENDER_TEMPLATE_PATTERN.match?(line)
+          line.sub(RENDER_TEMPLATE_PATTERN, "")
+        else
+          line
+        end
+      end
+      add_silencer { |line| !APP_DIRS_PATTERN.match?(line) }
+    end
+  end
+end
diff --git a/cli.rb b/cli.rb
new file mode 100644
index 0000000000000..e56e604fdcdaf
--- /dev/null
+++ b/cli.rb
@@ -0,0 +1,19 @@
+# frozen_string_literal: true
+
+require "rails/app_loader"
+
+# If we are inside a Rails application this method performs an exec and thus
+# the rest of this script is not run.
+Rails::AppLoader.exec_app
+
+require "rails/ruby_version_check"
+Signal.trap("INT") { puts; exit(1) }
+
+require "rails/command"
+
+if ARGV.first == "plugin"
+  ARGV.shift
+  Rails::Command.invoke :plugin, ARGV
+else
+  Rails::Command.invoke :application, ARGV
+end
diff --git a/code_statistics.rb b/code_statistics.rb
new file mode 100644
index 0000000000000..cead365037e79
--- /dev/null
+++ b/code_statistics.rb
@@ -0,0 +1,117 @@
+# frozen_string_literal: true
+
+require "rails/code_statistics_calculator"
+require "active_support/core_ext/enumerable"
+
+class CodeStatistics # :nodoc:
+  TEST_TYPES = ["Controller tests",
+                "Helper tests",
+                "Model tests",
+                "Mailer tests",
+                "Mailbox tests",
+                "Channel tests",
+                "Job tests",
+                "Integration tests",
+                "System tests"]
+
+  HEADERS = { lines: " Lines", code_lines: "   LOC", classes: "Classes", methods: "Methods" }
+
+  def initialize(*pairs)
+    @pairs      = pairs
+    @statistics = calculate_statistics
+    @total      = calculate_total if pairs.length > 1
+  end
+
+  def to_s
+    print_header
+    @pairs.each { |pair| print_line(pair.first, @statistics[pair.first]) }
+    print_splitter
+
+    if @total
+      print_line("Total", @total)
+      print_splitter
+    end
+
+    print_code_test_stats
+  end
+
+  private
+    def calculate_statistics
+      Hash[@pairs.map { |pair| [pair.first, calculate_directory_statistics(pair.last)] }]
+    end
+
+    def calculate_directory_statistics(directory, pattern = /^(?!\.).*?\.(rb|js|ts|css|scss|coffee|rake|erb)$/)
+      stats = CodeStatisticsCalculator.new
+
+      Dir.foreach(directory) do |file_name|
+        path = "#{directory}/#{file_name}"
+
+        if File.directory?(path) && !file_name.start_with?(".")
+          stats.add(calculate_directory_statistics(path, pattern))
+        elsif file_name&.match?(pattern)
+          stats.add_by_file_path(path)
+        end
+      end
+
+      stats
+    end
+
+    def calculate_total
+      @statistics.each_with_object(CodeStatisticsCalculator.new) do |pair, total|
+        total.add(pair.last)
+      end
+    end
+
+    def calculate_code
+      code_loc = 0
+      @statistics.each { |k, v| code_loc += v.code_lines unless TEST_TYPES.include? k }
+      code_loc
+    end
+
+    def calculate_tests
+      test_loc = 0
+      @statistics.each { |k, v| test_loc += v.code_lines if TEST_TYPES.include? k }
+      test_loc
+    end
+
+    def width_for(label)
+      [@statistics.values.sum { |s| s.public_send(label) }.to_s.size, HEADERS[label].length].max
+    end
+
+    def print_header
+      print_splitter
+      print "| Name                "
+      HEADERS.each do |k, v|
+        print " | #{v.rjust(width_for(k))}"
+      end
+      puts " | M/C | LOC/M |"
+      print_splitter
+    end
+
+    def print_splitter
+      print "+----------------------"
+      HEADERS.each_key do |k|
+        print "+#{'-' * (width_for(k) + 2)}"
+      end
+      puts "+-----+-------+"
+    end
+
+    def print_line(name, statistics)
+      m_over_c   = (statistics.methods / statistics.classes) rescue 0
+      loc_over_m = (statistics.code_lines / statistics.methods) - 2 rescue 0
+
+      print "| #{name.ljust(20)} "
+      HEADERS.each_key do |k|
+        print "| #{statistics.send(k).to_s.rjust(width_for(k))} "
+      end
+      puts "| #{m_over_c.to_s.rjust(3)} | #{loc_over_m.to_s.rjust(5)} |"
+    end
+
+    def print_code_test_stats
+      code  = calculate_code
+      tests = calculate_tests
+
+      puts "  Code LOC: #{code}     Test LOC: #{tests}     Code to Test Ratio: 1:#{sprintf("%.1f", tests.to_f / code)}"
+      puts ""
+    end
+end
diff --git a/code_statistics_calculator.rb b/code_statistics_calculator.rb
new file mode 100644
index 0000000000000..1503eb7eefc20
--- /dev/null
+++ b/code_statistics_calculator.rb
@@ -0,0 +1,97 @@
+# frozen_string_literal: true
+
+class CodeStatisticsCalculator # :nodoc:
+  attr_reader :lines, :code_lines, :classes, :methods
+
+  PATTERNS = {
+    rb: {
+      line_comment: /^\s*#/,
+      begin_block_comment: /^=begin/,
+      end_block_comment: /^=end/,
+      class: /^\s*class\s+[_A-Z]/,
+      method: /^\s*def\s+[_a-z]/,
+    },
+    erb: {
+      line_comment: %r{((^\s*<%#.*%>)|(<!--.*-->))},
+    },
+    css: {
+      line_comment: %r{^\s*/\*.*\*/},
+    },
+    scss: {
+      line_comment: %r{((^\s*/\*.*\*/)|(^\s*//))},
+    },
+    js: {
+      line_comment: %r{^\s*//},
+      begin_block_comment: %r{^\s*/\*},
+      end_block_comment: %r{\*/},
+      method: /function(\s+[_a-zA-Z][\da-zA-Z]*)?\s*\(/,
+    },
+    coffee: {
+      line_comment: /^\s*#/,
+      begin_block_comment: /^\s*###/,
+      end_block_comment: /^\s*###/,
+      class: /^\s*class\s+[_A-Z]/,
+      method: /[-=]>/,
+    }
+  }
+
+  PATTERNS[:minitest] = PATTERNS[:rb].merge method: /^\s*(def|test)\s+['"_a-z]/
+  PATTERNS[:rake] = PATTERNS[:rb]
+
+  def initialize(lines = 0, code_lines = 0, classes = 0, methods = 0)
+    @lines = lines
+    @code_lines = code_lines
+    @classes = classes
+    @methods = methods
+  end
+
+  def add(code_statistics_calculator)
+    @lines += code_statistics_calculator.lines
+    @code_lines += code_statistics_calculator.code_lines
+    @classes += code_statistics_calculator.classes
+    @methods += code_statistics_calculator.methods
+  end
+
+  def add_by_file_path(file_path)
+    File.open(file_path) do |f|
+      add_by_io(f, file_type(file_path))
+    end
+  end
+
+  def add_by_io(io, file_type)
+    patterns = PATTERNS[file_type] || {}
+
+    comment_started = false
+
+    while line = io.gets
+      @lines += 1
+
+      if comment_started
+        if patterns[:end_block_comment] && patterns[:end_block_comment].match?(line)
+          comment_started = false
+        end
+        next
+      else
+        if patterns[:begin_block_comment] && patterns[:begin_block_comment].match?(line)
+          comment_started = true
+          next
+        end
+      end
+
+      @classes   += 1 if patterns[:class] && patterns[:class].match?(line)
+      @methods   += 1 if patterns[:method] && patterns[:method].match?(line)
+      if !line.match?(/^\s*$/) && (patterns[:line_comment].nil? || !line.match?(patterns[:line_comment]))
+        @code_lines += 1
+      end
+    end
+  end
+
+  private
+    def file_type(file_path)
+      if file_path.end_with? "_test.rb"
+        :minitest
+      else
+        File.extname(file_path).delete_prefix(".").downcase.to_sym
+      end
+    end
+end
diff --git a/command.rb b/command.rb
new file mode 100644
index 0000000000000..bd70d51d91634
--- /dev/null
+++ b/command.rb
@@ -0,0 +1,121 @@
+# frozen_string_literal: true
+
+require "active_support"
+require "active_support/core_ext/enumerable"
+require "active_support/core_ext/object/blank"
+
+require "thor"
+
+module Rails
+  module Command
+    extend ActiveSupport::Autoload
+
+    autoload :Behavior
+    autoload :Base
+
+    include Behavior
+
+    HELP_MAPPINGS = %w(-h -? --help)
+
+    class << self
+      def hidden_commands # :nodoc:
+        @hidden_commands ||= []
+      end
+
+      def environment # :nodoc:
+        ENV["RAILS_ENV"].presence || ENV["RACK_ENV"].presence || "development"
+      end
+
+      # Receives a namespace, arguments, and the behavior to invoke the command.
+      def invoke(full_namespace, args = [], **config)
+        namespace = full_namespace = full_namespace.to_s
+
+        if char = namespace =~ /:(\w+)$/
+          command_name, namespace = $1, namespace.slice(0, char)
+        else
+          command_name = namespace
+        end
+
+        command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
+        command_name, namespace, args = "application", "application", ["--help"] if rails_new_with_no_path?(args)
+        command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)
+
+        original_argv = ARGV.dup
+        ARGV.replace(args)
+
+        command = find_by_namespace(namespace, command_name)
+        if command && command.all_commands[command_name]
+          command.perform(command_name, args, config)
+        else
+          args = ["--describe", full_namespace] if HELP_MAPPINGS.include?(args[0])
+          find_by_namespace("rake").perform(full_namespace, args, config)
+        end
+      ensure
+        ARGV.replace(original_argv)
+      end
+
+      # Rails finds namespaces similar to Thor, it only adds one rule:
+      #
+      # Command names must end with "_command.rb". This is required because Rails
+      # looks in load paths and loads the command just before it's going to be used.
+      #
+      #   find_by_namespace :webrat, :integration
+      #
+      # Will search for the following commands:
+      #
+      #   "webrat", "webrat:integration", "rails:webrat", "rails:webrat:integration"
+      #
+      def find_by_namespace(namespace, command_name = nil) # :nodoc:
+        lookups = [ namespace ]
+        lookups << "#{namespace}:#{command_name}" if command_name
+        lookups.concat lookups.map { |lookup| "rails:#{lookup}" }
+
+        lookup(lookups)
+
+        namespaces = subclasses.index_by(&:namespace)
+        namespaces[(lookups & namespaces.keys).first]
+      end
+
+      # Returns the root of the Rails engine or app running the command.
+      def root
+        if defined?(ENGINE_ROOT)
+          Pathname.new(ENGINE_ROOT)
+        elsif defined?(APP_PATH)
+          Pathname.new(File.expand_path("../..", APP_PATH))
+        end
+      end
+
+      def print_commands # :nodoc:
+        commands.each { |command| puts("  #{command}") }
+      end
+
+      private
+        COMMANDS_IN_USAGE = %w(generate console server test test:system dbconsole new)
+        private_constant :COMMANDS_IN_USAGE
+
+        def rails_new_with_no_path?(args)
+          args == ["new"]
+        end
+
+        def commands
+          lookup!
+
+          visible_commands = (subclasses - hidden_commands).flat_map(&:printing_commands)
+
+          (visible_commands - COMMANDS_IN_USAGE).sort
+        end
+
+        def command_type # :doc:
+          @command_type ||= "command"
+        end
+
+        def lookup_paths # :doc:
+          @lookup_paths ||= %w( rails/commands commands )
+        end
+
+        def file_lookup_paths # :doc:
+          @file_lookup_paths ||= [ "{#{lookup_paths.join(',')}}", "**", "*_command.rb" ]
+        end
+    end
+  end
+end
diff --git a/commands.rb b/commands.rb
new file mode 100644
index 0000000000000..77961a0292e59
--- /dev/null
+++ b/commands.rb
@@ -0,0 +1,18 @@
+# frozen_string_literal: true
+
+require "rails/command"
+
+aliases = {
+  "g"  => "generate",
+  "d"  => "destroy",
+  "c"  => "console",
+  "s"  => "server",
+  "db" => "dbconsole",
+  "r"  => "runner",
+  "t"  => "test"
+}
+
+command = ARGV.shift
+command = aliases[command] || command
+
+Rails::Command.invoke command, ARGV
diff --git a/configuration.rb b/configuration.rb
new file mode 100644
index 0000000000000..6d92e102f8051
--- /dev/null
+++ b/configuration.rb
@@ -0,0 +1,161 @@
+# frozen_string_literal: true
+
+require "active_support/ordered_options"
+require "active_support/core_ext/object"
+require "rails/paths"
+require "rails/rack"
+
+module Rails
+  module Configuration
+    # MiddlewareStackProxy is a proxy for the Rails middleware stack that allows
+    # you to configure middlewares in your application. It works basically as a
+    # command recorder, saving each command to be applied after initialization
+    # over the default middleware stack, so you can add, swap, or remove any
+    # middleware in Rails.
+    #
+    # You can add your own middlewares by using the +config.middleware.use+ method:
+    #
+    #     config.middleware.use Magical::Unicorns
+    #
+    # This will put the <tt>Magical::Unicorns</tt> middleware on the end of the stack.
+    # You can use +insert_before+ if you wish to add a middleware before another:
+    #
+    #     config.middleware.insert_before Rack::Head, Magical::Unicorns
+    #
+    # There's also +insert_after+ which will insert a middleware after another:
+    #
+    #     config.middleware.insert_after Rack::Head, Magical::Unicorns
+    #
+    # Middlewares can also be completely swapped out and replaced with others:
+    #
+    #     config.middleware.swap ActionDispatch::Flash, Magical::Unicorns
+    #
+    # Middlewares can be moved from one place to another:
+    #
+    #     config.middleware.move_before ActionDispatch::Flash, Magical::Unicorns
+    #
+    # This will move the <tt>Magical::Unicorns</tt> middleware before the
+    # <tt>ActionDispatch::Flash</tt>. You can also move it after:
+    #
+    #     config.middleware.move_after ActionDispatch::Flash, Magical::Unicorns
+    #
+    # And finally they can also be removed from the stack completely:
+    #
+    #     config.middleware.delete ActionDispatch::Flash
+    #
+    class MiddlewareStackProxy
+      def initialize(operations = [], delete_operations = [])
+        @operations = operations
+        @delete_operations = delete_operations
+      end
+
+      def insert_before(...)
+        @operations << -> middleware { middleware.insert_before(...) }
+      end
+
+      alias :insert :insert_before
+
+      def insert_after(...)
+        @operations << -> middleware { middleware.insert_after(...) }
+      end
+
+      def swap(...)
+        @operations << -> middleware { middleware.swap(...) }
+      end
+
+      def use(...)
+        @operations << -> middleware { middleware.use(...) }
+      end
+
+      def delete(...)
+        @delete_operations << -> middleware { middleware.delete(...) }
+      end
+
+      def move_before(...)
+        @delete_operations << -> middleware { middleware.move_before(...) }
+      end
+
+      alias :move :move_before
+
+      def move_after(...)
+        @delete_operations << -> middleware { middleware.move_after(...) }
+      end
+
+      def unshift(...)
+        @operations << -> middleware { middleware.unshift(...) }
+      end
+
+      def merge_into(other) # :nodoc:
+        (@operations + @delete_operations).each do |operation|
+          operation.call(other)
+        end
+
+        other
+      end
+
+      def +(other) # :nodoc:
+        MiddlewareStackProxy.new(@operations + other.operations, @delete_operations + other.delete_operations)
+      end
+
+      protected
+        attr_reader :operations, :delete_operations
+    end
+
+    class Generators # :nodoc:
+      attr_accessor :aliases, :options, :templates, :fallbacks, :colorize_logging, :api_only
+      attr_reader :hidden_namespaces, :after_generate_callbacks
+
+      def initialize
+        @aliases = Hash.new { |h, k| h[k] = {} }
+        @options = Hash.new { |h, k| h[k] = {} }
+        @fallbacks = {}
+        @templates = []
+        @colorize_logging = true
+        @api_only = false
+        @hidden_namespaces = []
+        @after_generate_callbacks = []
+      end
+
+      def initialize_copy(source)
+        @aliases = @aliases.deep_dup
+        @options = @options.deep_dup
+        @fallbacks = @fallbacks.deep_dup
+        @templates = @templates.dup
+      end
+
+      def hide_namespace(namespace)
+        @hidden_namespaces << namespace
+      end
+
+      def after_generate(&block)
+        @after_generate_callbacks << block
+      end
+
+      def method_missing(method, *args)
+        method = method.to_s.delete_suffix("=").to_sym
+
+        if args.empty?
+          if method == :rails
+            return @options[method]
+          else
+            return @options[:rails][method]
+          end
+        end
+
+        if method == :rails || args.first.is_a?(Hash)
+          namespace, configuration = method, args.shift
+        else
+          namespace, configuration = args.shift, args.shift
+          namespace = namespace.to_sym if namespace.respond_to?(:to_sym)
+          @options[:rails][method] = namespace
+        end
+
+        if configuration
+          aliases = configuration.delete(:aliases)
+          @aliases[namespace].merge!(aliases) if aliases
+          @options[namespace].merge!(configuration)
+        end
+      end
+    end
+  end
+end
diff --git a/console b/console
new file mode 100644
index 0000000000000..ee08e22502283
--- /dev/null
+++ b/console
@@ -0,0 +1,11 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+require "bundler"
+Bundler.setup
+
+require "rails/all"
+require "active_support/all"
+require "irb"
+require "irb/completion"
+IRB.start
diff --git a/dev_caching.rb b/dev_caching.rb
new file mode 100644
index 0000000000000..ff629b2527a08
--- /dev/null
+++ b/dev_caching.rb
@@ -0,0 +1,44 @@
+# frozen_string_literal: true
+
+require "fileutils"
+
+module Rails
+  module DevCaching # :nodoc:
+    class << self
+      FILE = "tmp/caching-dev.txt"
+
+      def enable_by_file
+        FileUtils.mkdir_p("tmp")
+
+        if File.exist?(FILE)
+          delete_cache_file
+          puts "Development mode is no longer being cached."
+        else
+          create_cache_file
+          puts "Development mode is now being cached."
+        end
+
+        FileUtils.touch "tmp/restart.txt"
+      end
+
+      def enable_by_argument(caching)
+        FileUtils.mkdir_p("tmp")
+
+        if caching
+          create_cache_file
+        elsif caching == false && File.exist?(FILE)
+          delete_cache_file
+        end
+      end
+
+      private
+        def create_cache_file
+          FileUtils.touch FILE
+        end
+
+        def delete_cache_file
+          File.delete FILE
+        end
+    end
+  end
+end
diff --git a/engine.rb b/engine.rb
new file mode 100644
index 0000000000000..4b2ed4b9c2561
--- /dev/null
+++ b/engine.rb
@@ -0,0 +1,727 @@
+# frozen_string_literal: true
+
+require "rails/railtie"
+require "rails/engine/railties"
+require "active_support/callbacks"
+require "active_support/core_ext/module/delegation"
+require "active_support/core_ext/object/try"
+require "pathname"
+require "thread"
+
+module Rails
+  # <tt>Rails::Engine</tt> allows you to wrap a specific Rails application or subset of
+  # functionality and share it with other applications or within a larger packaged application.
+  # Every Rails::Application is just an engine, which allows for simple
+  # feature and application sharing.
+  #
+  # Any <tt>Rails::Engine</tt> is also a Rails::Railtie, so the same
+  # methods (like <tt>rake_tasks</tt> and +generators+) and configuration
+  # options that are available in railties can also be used in engines.
+  #
+  # == Creating an Engine
+  #
+  # If you want a gem to behave as an engine, you have to specify an +Engine+
+  # for it somewhere inside your plugin's +lib+ folder (similar to how we
+  # specify a +Railtie+):
+  #
+  #   # lib/my_engine.rb
+  #   module MyEngine
+  #     class Engine < Rails::Engine
+  #     end
+  #   end
+  #
+  # Then ensure that this file is loaded at the top of your <tt>config/application.rb</tt>
+  # (or in your +Gemfile+), and it will automatically load models, controllers, and helpers
+  # inside +app+, load routes at <tt>config/routes.rb</tt>, load locales at
+  # <tt>config/locales/**/*</tt>, and load tasks at <tt>lib/tasks/**/*</tt>.
+  #
+  # == Configuration
+  #
+  # Like railties, engines can access a config object which contains configuration shared by
+  # all railties and the application.
+  # Additionally, each engine can access <tt>autoload_paths</tt>, <tt>eager_load_paths</tt> and
+  # <tt>autoload_once_paths</tt> settings which are scoped to that engine.
+  #
+  #   class MyEngine < Rails::Engine
+  #     # Add a load path for this specific Engine
+  #     config.autoload_paths << File.expand_path("lib/some/path", __dir__)
+  #
+  #     initializer "my_engine.add_middleware" do |app|
+  #       app.middleware.use MyEngine::Middleware
+  #     end
+  #   end
+  #
+  # == Generators
+  #
+  # You can set up generators for engines with <tt>config.generators</tt> method:
+  #
+  #   class MyEngine < Rails::Engine
+  #     config.generators do |g|
+  #       g.orm             :active_record
+  #       g.template_engine :erb
+  #       g.test_framework  :test_unit
+  #     end
+  #   end
+  #
+  # You can also set generators for an application by using <tt>config.app_generators</tt>:
+  #
+  #   class MyEngine < Rails::Engine
+  #     # note that you can also pass block to app_generators in the same way you
+  #     # can pass it to generators method
+  #     config.app_generators.orm :datamapper
+  #   end
+  #
+  # == Paths
+  #
+  # Applications and engines have flexible path configuration, meaning that you
+  # are not required to place your controllers at <tt>app/controllers</tt>, but
+  # in any place which you find convenient.
+  #
+  # For example, let's suppose you want to place your controllers in <tt>lib/controllers</tt>.
+  # You can set that as an option:
+  #
+  #   class MyEngine < Rails::Engine
+  #     paths["app/controllers"] = "lib/controllers"
+  #   end
+  #
+  # You can also have your controllers loaded from both <tt>app/controllers</tt> and
+  # <tt>lib/controllers</tt>:
+  #
+  #   class MyEngine < Rails::Engine
+  #     paths["app/controllers"] << "lib/controllers"
+  #   end
+  #
+  # The available paths in an engine are:
+  #
+  #   class MyEngine < Rails::Engine
+  #     paths["app"]                 # => ["app"]
+  #     paths["app/controllers"]     # => ["app/controllers"]
+  #     paths["app/helpers"]         # => ["app/helpers"]
+  #     paths["app/models"]          # => ["app/models"]
+  #     paths["app/views"]           # => ["app/views"]
+  #     paths["lib"]                 # => ["lib"]
+  #     paths["lib/tasks"]           # => ["lib/tasks"]
+  #     paths["config"]              # => ["config"]
+  #     paths["config/initializers"] # => ["config/initializers"]
+  #     paths["config/locales"]      # => ["config/locales"]
+  #     paths["config/routes.rb"]    # => ["config/routes.rb"]
+  #   end
+  #
+  # The <tt>Application</tt> class adds a couple more paths to this set. And as in your
+  # <tt>Application</tt>, all folders under +app+ are automatically added to the load path.
+  # If you have an <tt>app/services</tt> folder for example, it will be added by default.
+  #
+  # == Endpoint
+  #
+  # An engine can also be a Rack application. It can be useful if you have a Rack application that
+  # you would like to provide with some of the +Engine+'s features.
+  #
+  # To do that, use the +endpoint+ method:
+  #
+  #   module MyEngine
+  #     class Engine < Rails::Engine
+  #       endpoint MyRackApplication
+  #     end
+  #   end
+  #
+  # Now you can mount your engine in application's routes:
+  #
+  #   Rails.application.routes.draw do
+  #     mount MyEngine::Engine => "/engine"
+  #   end
+  #
+  # == Middleware stack
+  #
+  # As an engine can now be a Rack endpoint, it can also have a middleware
+  # stack. The usage is exactly the same as in <tt>Application</tt>:
+  #
+  #   module MyEngine
+  #     class Engine < Rails::Engine
+  #       middleware.use SomeMiddleware
+  #     end
+  #   end
+  #
+  # == Routes
+  #
+  # If you don't specify an endpoint, routes will be used as the default
+  # endpoint. You can use them just like you use an application's routes:
+  #
+  #   # ENGINE/config/routes.rb
+  #   MyEngine::Engine.routes.draw do
+  #     get "/" => "posts#index"
+  #   end
+  #
+  # == Mount priority
+  #
+  # Note that now there can be more than one router in your application, and it's better to avoid
+  # passing requests through many routers. Consider this situation:
+  #
+  #   Rails.application.routes.draw do
+  #     mount MyEngine::Engine => "/blog"
+  #     get "/blog/omg" => "main#omg"
+  #   end
+  #
+  # +MyEngine+ is mounted at <tt>/blog</tt>, and <tt>/blog/omg</tt> points to application's
+  # controller. In such a situation, requests to <tt>/blog/omg</tt> will go through +MyEngine+,
+  # and if there is no such route in +Engine+'s routes, it will be dispatched to <tt>main#omg</tt>.
+  # It's much better to swap that:
+  #
+  #   Rails.application.routes.draw do
+  #     get "/blog/omg" => "main#omg"
+  #     mount MyEngine::Engine => "/blog"
+  #   end
+  #
+  # Now, +Engine+ will get only requests that were not handled by +Application+.
+  #
+  # == Engine name
+  #
+  # There are some places where an Engine's name is used:
+  #
+  # * routes: when you mount an Engine with <tt>mount(MyEngine::Engine => '/my_engine')</tt>,
+  #   it's used as default <tt>:as</tt> option
+  # * rake task for installing migrations <tt>my_engine:install:migrations</tt>
+  #
+  # Engine name is set by default based on class name. For <tt>MyEngine::Engine</tt> it will be
+  # <tt>my_engine_engine</tt>. You can change it manually using the <tt>engine_name</tt> method:
+  #
+  #   module MyEngine
+  #     class Engine < Rails::Engine
+  #       engine_name "my_engine"
+  #     end
+  #   end
+  #
+  # == Isolated Engine
+  #
+  # Normally when you create controllers, helpers, and models inside an engine, they are treated
+  # as if they were created inside the application itself. This means that all helpers and
+  # named routes from the application will be available to your engine's controllers as well.
+  #
+  # However, sometimes you want to isolate your engine from the application, especially if your engine
+  # has its own router. To do that, you simply need to call +isolate_namespace+. This method requires
+  # you to pass a module where all your controllers, helpers, and models should be nested to:
+  #
+  #   module MyEngine
+  #     class Engine < Rails::Engine
+  #       isolate_namespace MyEngine
+  #     end
+  #   end
+  #
+  # With such an engine, everything that is inside the +MyEngine+ module will be isolated from
+  # the application.
+  #
+  # Consider this controller:
+  #
+  #   module MyEngine
+  #     class FooController < ActionController::Base
+  #     end
+  #   end
+  #
+  # If the +MyEngine+ engine is marked as isolated, +FooController+ only has
+  # access to helpers from +MyEngine+, and <tt>url_helpers</tt> from
+  # <tt>MyEngine::Engine.routes</tt>.
+  #
+  # The next thing that changes in isolated engines is the behavior of routes.
+  # Normally, when you namespace your controllers, you also need to namespace
+  # the related routes. With an isolated engine, the engine's namespace is
+  # automatically applied, so you don't need to specify it explicitly in your
+  # routes:
+  #
+  #   MyEngine::Engine.routes.draw do
+  #     resources :articles
+  #   end
+  #
+  # If +MyEngine+ is isolated, the routes above will point to
+  # <tt>MyEngine::ArticlesController</tt>. You also don't need to use longer
+  # URL helpers like +my_engine_articles_path+. Instead, you should simply use
+  # +articles_path+, like you would do with your main application.
+  #
+  # To make this behavior consistent with other parts of the framework,
+  # isolated engines also have an effect on ActiveModel::Naming. In a
+  # normal Rails app, when you use a namespaced model such as
+  # <tt>Namespace::Article</tt>, ActiveModel::Naming will generate
+  # names with the prefix "namespace". In an isolated engine, the prefix will
+  # be omitted in URL helpers and form fields, for convenience.
+  #
+  #   polymorphic_url(MyEngine::Article.new)
+  #   # => "articles_path" # not "my_engine_articles_path"
+  #
+  #   form_for(MyEngine::Article.new) do
+  #     text_field :title # => <input type="text" name="article[title]" id="article_title" />
+  #   end
+  #
+  # Additionally, an isolated engine will set its own name according to its
+  # namespace, so <tt>MyEngine::Engine.engine_name</tt> will return
+  # "my_engine". It will also set +MyEngine.table_name_prefix+ to "my_engine_",
+  # meaning for example that <tt>MyEngine::Article</tt> will use the
+  # +my_engine_articles+ database table by default.
+  #
+  # == Using Engine's routes outside Engine
+  #
+  # Since you can now mount an engine inside application's routes, you do not have direct access to +Engine+'s
+  # <tt>url_helpers</tt> inside +Application+. When you mount an engine in an application's routes, a special helper is
+  # created to allow you to do that. Consider such a scenario:
+  #
+  #   # config/routes.rb
+  #   Rails.application.routes.draw do
+  #     mount MyEngine::Engine => "/my_engine", as: "my_engine"
+  #     get "/foo" => "foo#index"
+  #   end
+  #
+  # Now, you can use the <tt>my_engine</tt> helper inside your application:
+  #
+  #   class FooController < ApplicationController
+  #     def index
+  #       my_engine.root_url # => /my_engine/
+  #     end
+  #   end
+  #
+  # There is also a <tt>main_app</tt> helper that gives you access to application's routes inside Engine:
+  #
+  #   module MyEngine
+  #     class BarController
+  #       def index
+  #         main_app.foo_path # => /foo
+  #       end
+  #     end
+  #   end
+  #
+  # Note that the <tt>:as</tt> option given to mount takes the <tt>engine_name</tt> as default, so most of the time
+  # you can simply omit it.
+  #
+  # Finally, if you want to generate a URL to an engine's route using
+  # <tt>polymorphic_url</tt>, you also need to pass the engine helper. Let's
+  # say that you want to create a form pointing to one of the engine's routes.
+  # All you need to do is pass the helper as the first element in array with
+  # attributes for URL:
+  #
+  #   form_for([my_engine, @user])
+  #
+  # This code will use <tt>my_engine.user_path(@user)</tt> to generate the proper route.
+  #
+  # == Isolated engine's helpers
+  #
+  # Sometimes you may want to isolate engine, but use helpers that are defined for it.
+  # If you want to share just a few specific helpers you can add them to application's
+  # helpers in ApplicationController:
+  #
+  #   class ApplicationController < ActionController::Base
+  #     helper MyEngine::SharedEngineHelper
+  #   end
+  #
+  # If you want to include all of the engine's helpers, you can use the #helper method on an engine's
+  # instance:
+  #
+  #   class ApplicationController < ActionController::Base
+  #     helper MyEngine::Engine.helpers
+  #   end
+  #
+  # It will include all of the helpers from engine's directory. Take into account this does
+  # not include helpers defined in controllers with helper_method or other similar solutions,
+  # only helpers defined in the helpers directory will be included.
+  #
+  # == Migrations & seed data
+  #
+  # Engines can have their own migrations. The default path for migrations is exactly the same
+  # as in application: <tt>db/migrate</tt>
+  #
+  # To use engine's migrations in application you can use the rake task below, which copies them to
+  # application's dir:
+  #
+  #   rake ENGINE_NAME:install:migrations
+  #
+  # Note that some of the migrations may be skipped if a migration with the same name already exists
+  # in application. In such a situation you must decide whether to leave that migration or rename the
+  # migration in the application and rerun copying migrations.
+  #
+  # If your engine has migrations, you may also want to prepare data for the database in
+  # the <tt>db/seeds.rb</tt> file. You can load that data using the <tt>load_seed</tt> method, e.g.
+  #
+  #   MyEngine::Engine.load_seed
+  #
+  # == Loading priority
+  #
+  # In order to change engine's priority you can use +config.railties_order+ in the main application.
+  # It will affect the priority of loading views, helpers, assets, and all the other files
+  # related to engine or application.
+  #
+  #   # load Blog::Engine with highest priority, followed by application and other railties
+  #   config.railties_order = [Blog::Engine, :main_app, :all]
+  class Engine < Railtie
+    autoload :Configuration, "rails/engine/configuration"
+
+    class << self
+      attr_accessor :called_from, :isolated
+
+      alias :isolated? :isolated
+      alias :engine_name :railtie_name
+
+      delegate :eager_load!, to: :instance
+
+      def inherited(base)
+        unless base.abstract_railtie?
+          Rails::Railtie::Configuration.eager_load_namespaces << base
+
+          base.called_from = begin
+            call_stack = caller_locations.map { |l| l.absolute_path || l.path }
+
+            File.dirname(call_stack.detect { |p| !p.match?(%r[railties[\w.-]*/lib/rails|rack[\w.-]*/lib/rack]) })
+          end
+        end
+
+        super
+      end
+
+      def find_root(from)
+        find_root_with_flag "lib", from
+      end
+
+      def endpoint(endpoint = nil)
+        @endpoint ||= nil
+        @endpoint = endpoint if endpoint
+        @endpoint
+      end
+
+      def isolate_namespace(mod)
+        engine_name(generate_railtie_name(mod.name))
+
+        routes.default_scope = { module: ActiveSupport::Inflector.underscore(mod.name) }
+        self.isolated = true
+
+        unless mod.respond_to?(:railtie_namespace)
+          name, railtie = engine_name, self
+
+          mod.singleton_class.instance_eval do
+            define_method(:railtie_namespace) { railtie }
+
+            unless mod.respond_to?(:table_name_prefix)
+              define_method(:table_name_prefix) { "#{name}_" }
+            end
+
+            unless mod.respond_to?(:use_relative_model_naming?)
+              class_eval "def use_relative_model_naming?; true; end", __FILE__, __LINE__
+            end
+
+            unless mod.respond_to?(:railtie_helpers_paths)
+              define_method(:railtie_helpers_paths) { railtie.helpers_paths }
+            end
+
+            unless mod.respond_to?(:railtie_routes_url_helpers)
+              define_method(:railtie_routes_url_helpers) { |include_path_helpers = true| railtie.routes.url_helpers(include_path_helpers) }
+            end
+          end
+        end
+      end
+
+      # Finds engine with given path.
+      def find(path)
+        expanded_path = File.expand_path path
+        Rails::Engine.subclasses.each do |klass|
+          engine = klass.instance
+          return engine if File.expand_path(engine.root) == expanded_path
+        end
+        nil
+      end
+    end
+
+    include ActiveSupport::Callbacks
+    define_callbacks :load_seed
+
+    delegate :middleware, :root, :paths, to: :config
+    delegate :engine_name, :isolated?, to: :class
+
+    def initialize
+      @_all_autoload_paths = nil
+      @_all_load_paths     = nil
+      @app                 = nil
+      @config              = nil
+      @env_config          = nil
+      @helpers             = nil
+      @routes              = nil
+      @app_build_lock      = Mutex.new
+      super
+    end
+
+    # Load console and invoke the registered hooks.
+    # Check Rails::Railtie.console for more info.
+    def load_console(app = self)
+      require "rails/console/app"
+      require "rails/console/helpers"
+      run_console_blocks(app)
+      self
+    end
+
+    # Load Rails runner and invoke the registered hooks.
+    # Check Rails::Railtie.runner for more info.
+    def load_runner(app = self)
+      run_runner_blocks(app)
+      self
+    end
+
+    # Load Rake and railties tasks, and invoke the registered hooks.
+    # Check Rails::Railtie.rake_tasks for more info.
+    def load_tasks(app = self)
+      require "rake"
+      run_tasks_blocks(app)
+      self
+    end
+
+    # Load Rails generators and invoke the registered hooks.
+    # Check Rails::Railtie.generators for more info.
+    def load_generators(app = self)
+      require "rails/generators"
+      run_generators_blocks(app)
+      Rails::Generators.configure!(app.config.generators)
+      self
+    end
+
+    # Invoke the server registered hooks.
+    # Check Rails::Railtie.server for more info.
+    def load_server(app = self)
+      run_server_blocks(app)
+      self
+    end
+
+    def eager_load!
+      # Already done by Zeitwerk::Loader.eager_load_all. By now, we leave the
+      # method as a no-op for backwards compatibility.
+    end
+
+    def railties
+      @railties ||= Railties.new
+    end
+
+    # Returns a module with all the helpers defined for the engine.
+    def helpers
+      @helpers ||= begin
+        helpers = Module.new
+        all = ActionController::Base.all_helpers_from_path(helpers_paths)
+        ActionController::Base.modules_for_helpers(all).each do |mod|
+          helpers.include(mod)
+        end
+        helpers
+      end
+    end
+
+    # Returns all registered helpers paths.
+    def helpers_paths
+      paths["app/helpers"].existent
+    end
+
+    # Returns the underlying Rack application for this engine.
+    def app
+      @app || @app_build_lock.synchronize {
+        @app ||= begin
+          stack = default_middleware_stack
+          config.middleware = build_middleware.merge_into(stack)
+          config.middleware.build(endpoint)
+        end
+      }
+    end
+
+    # Returns the endpoint for this engine. If none is registered,
+    # defaults to an ActionDispatch::Routing::RouteSet.
+    def endpoint
+      self.class.endpoint || routes
+    end
+
+    # Define the Rack API for this engine.
+    def call(env)
+      req = build_request env
+      app.call req.env
+    end
+
+    # Defines additional Rack env configuration that is added on each call.
+    def env_config
+      @env_config ||= {}
+    end
+
+    # Defines the routes for this engine. If a block is given to
+    # routes, it is appended to the engine.
+    def routes(&block)
+      @routes ||= ActionDispatch::Routing::RouteSet.new_with_config(config)
+      @routes.append(&block) if block_given?
+      @routes
+    end
+
+    # Define the configuration object for the engine.
+    def config
+      @config ||= Engine::Configuration.new(self.class.find_root(self.class.called_from))
+    end
+
+    # Load data from db/seeds.rb file. It can be used in to load engines'
+    # seeds, e.g.:
+    #
+    # Blog::Engine.load_seed
+    def load_seed
+      seed_file = paths["db/seeds.rb"].existent.first
+      run_callbacks(:load_seed) { load(seed_file) } if seed_file
+    end
+
+    initializer :load_environment_config, before: :load_environment_hook, group: :all do
+      paths["config/environments"].existent.each do |environment|
+        require environment
+      end
+    end
+
+    initializer :set_load_path, before: :bootstrap_hook do |app|
+      _all_load_paths(app.config.add_autoload_paths_to_load_path).reverse_each do |path|
+        $LOAD_PATH.unshift(path) if File.directory?(path)
+      end
+      $LOAD_PATH.uniq!
+    end
+
+    initializer :set_autoload_paths, before: :bootstrap_hook do
+      ActiveSupport::Dependencies.autoload_paths.unshift(*_all_autoload_paths)
+      ActiveSupport::Dependencies.autoload_once_paths.unshift(*_all_autoload_once_paths)
+
+      config.autoload_paths.freeze
+      config.autoload_once_paths.freeze
+    end
+
+    initializer :set_eager_load_paths, before: :bootstrap_hook do
+      ActiveSupport::Dependencies._eager_load_paths.merge(config.eager_load_paths)
+      config.eager_load_paths.freeze
+    end
+
+    initializer :add_routing_paths do |app|
+      routing_paths = paths["config/routes.rb"].existent
+      external_paths = self.paths["config/routes"].paths
+      routes.draw_paths.concat(external_paths)
+
+      if routes? || routing_paths.any?
+        app.routes_reloader.paths.unshift(*routing_paths)
+        app.routes_reloader.route_sets << routes
+        app.routes_reloader.external_routes.unshift(*external_paths)
+      end
+    end
+
+    # I18n load paths are a special case since the ones added
+    # later have higher priority.
+    initializer :add_locales do
+      config.i18n.railties_load_path << paths["config/locales"]
+    end
+
+    initializer :add_view_paths do
+      views = paths["app/views"].existent
+      unless views.empty?
+        ActiveSupport.on_load(:action_controller) { prepend_view_path(views) if respond_to?(:prepend_view_path) }
+        ActiveSupport.on_load(:action_mailer) { prepend_view_path(views) }
+      end
+    end
+
+    initializer :prepend_helpers_path do |app|
+      if !isolated? || (app == self)
+        app.config.helpers_paths.unshift(*paths["app/helpers"].existent)
+      end
+    end
+
+    initializer :load_config_initializers do
+      config.paths["config/initializers"].existent.sort.each do |initializer|
+        load_config_initializer(initializer)
+      end
+    end
+
+    initializer :wrap_executor_around_load_seed do |app|
+      self.class.set_callback(:load_seed, :around) do |engine, seeds_block|
+        app.executor.wrap(&seeds_block)
+      end
+    end
+
+    initializer :engines_blank_point do
+      # We need this initializer so all extra initializers added in engines are
+      # consistently executed after all the initializers above across all engines.
+    end
+
+    rake_tasks do
+      next if is_a?(Rails::Application)
+      next unless has_migrations?
+
+      namespace railtie_name do
+        namespace :install do
+          desc "Copy migrations from #{railtie_name} to application"
+          task :migrations do
+            ENV["FROM"] = railtie_name
+            if Rake::Task.task_defined?("railties:install:migrations")
+              Rake::Task["railties:install:migrations"].invoke
+            else
+              Rake::Task["app:railties:install:migrations"].invoke
+            end
+          end
+        end
+      end
+    end
+
+    def routes? # :nodoc:
+      @routes
+    end
+
+    protected
+      def run_tasks_blocks(*) # :nodoc:
+        super
+        paths["lib/tasks"].existent.sort.each { |ext| load(ext) }
+      end
+
+    private
+      def load_config_initializer(initializer) # :doc:
+        ActiveSupport::Notifications.instrument("load_config_initializer.railties", initializer: initializer) do
+          load(initializer)
+        end
+      end
+
+      def has_migrations?
+        paths["db/migrate"].existent.any?
+      end
+
+      def self.find_root_with_flag(flag, root_path, default = nil) # :nodoc:
+        while root_path && File.directory?(root_path) && !File.exist?("#{root_path}/#{flag}")
+          parent = File.dirname(root_path)
+          root_path = parent != root_path && parent
+        end
+
+        root = File.exist?("#{root_path}/#{flag}") ? root_path : default
+        raise "Could not find root path for #{self}" unless root
+
+        Pathname.new File.realpath root
+      end
+
+      def default_middleware_stack
+        ActionDispatch::MiddlewareStack.new
+      end
+
+      def _all_autoload_once_paths
+        config.autoload_once_paths.uniq
+      end
+
+      def _all_autoload_paths
+        @_all_autoload_paths ||= begin
+          autoload_paths  = config.autoload_paths
+          autoload_paths += config.eager_load_paths
+          autoload_paths -= config.autoload_once_paths
+          autoload_paths.uniq
+        end
+      end
+
+      def _all_load_paths(add_autoload_paths_to_load_path)
+        @_all_load_paths ||= begin
+          load_paths = config.paths.load_paths
+          if add_autoload_paths_to_load_path
+            load_paths += _all_autoload_paths
+            load_paths += _all_autoload_once_paths
+          end
+          load_paths.uniq
+        end
+      end
+
+      def build_request(env)
+        env.merge!(env_config)
+        req = ActionDispatch::Request.new env
+        req.routes = routes
+        req.engine_script_name = req.script_name
+        req
+      end
+
+      def build_middleware
+        config.middleware
+      end
+  end
+end
diff --git a/gem_version.rb b/gem_version.rb
new file mode 100644
index 0000000000000..752f6f3f08e3d
--- /dev/null
+++ b/gem_version.rb
@@ -0,0 +1,17 @@
+# frozen_string_literal: true
+
+module Rails
+  # Returns the currently loaded version of Rails as a <tt>Gem::Version</tt>.
+  def self.gem_version
+    Gem::Version.new VERSION::STRING
+  end
+
+  module VERSION
+    MAJOR = 7
+    MINOR = 0
+    TINY  = 4
+    PRE   = nil
+
+    STRING = [MAJOR, MINOR, TINY, PRE].compact.join(".")
+  end
+end
diff --git a/generators.rb b/generators.rb
new file mode 100644
index 0000000000000..c4220ef6c6ff8
--- /dev/null
+++ b/generators.rb
@@ -0,0 +1,331 @@
+# frozen_string_literal: true
+
+activesupport_path = File.expand_path("../../../activesupport/lib", __dir__)
+$:.unshift(activesupport_path) if File.directory?(activesupport_path) && !$:.include?(activesupport_path)
+
+require "thor/group"
+require "rails/command"
+
+require "active_support/core_ext/array/extract_options"
+require "active_support/core_ext/enumerable"
+require "active_support/core_ext/hash/deep_merge"
+require "active_support/core_ext/module/attribute_accessors"
+require "active_support/core_ext/string/indent"
+require "active_support/core_ext/string/inflections"
+
+module Rails
+  module Generators
+    include Rails::Command::Behavior
+
+    autoload :Actions,         "rails/generators/actions"
+    autoload :ActiveModel,     "rails/generators/active_model"
+    autoload :Base,            "rails/generators/base"
+    autoload :Migration,       "rails/generators/migration"
+    autoload :Database,        "rails/generators/database"
+    autoload :AppName,         "rails/generators/app_name"
+    autoload :NamedBase,       "rails/generators/named_base"
+    autoload :ResourceHelpers, "rails/generators/resource_helpers"
+    autoload :TestCase,        "rails/generators/test_case"
+
+    mattr_accessor :namespace
+
+    DEFAULT_ALIASES = {
+      rails: {
+        actions: "-a",
+        orm: "-o",
+        javascripts: "-j",
+        resource_controller: "-c",
+        scaffold_controller: "-c",
+        stylesheets: "-y",
+        template_engine: "-e",
+        test_framework: "-t"
+      },
+
+      test_unit: {
+        fixture_replacement: "-r",
+      }
+    }
+
+    DEFAULT_OPTIONS = {
+      rails: {
+        api: false,
+        assets: true,
+        force_plural: false,
+        helper: true,
+        integration_tool: nil,
+        orm: false,
+        resource_controller: :controller,
+        resource_route: true,
+        scaffold_controller: :scaffold_controller,
+        system_tests: nil,
+        test_framework: nil,
+        template_engine: :erb
+      }
+    }
+
+    class << self
+      def configure!(config) # :nodoc:
+        api_only! if config.api_only
+        no_color! unless config.colorize_logging
+        aliases.deep_merge! config.aliases
+        options.deep_merge! config.options
+        fallbacks.merge! config.fallbacks
+        templates_path.concat config.templates
+        templates_path.uniq!
+        hide_namespaces(*config.hidden_namespaces)
+        after_generate_callbacks.replace config.after_generate_callbacks
+      end
+
+      def templates_path # :nodoc:
+        @templates_path ||= []
+      end
+
+      def aliases # :nodoc:
+        @aliases ||= DEFAULT_ALIASES.dup
+      end
+
+      def options # :nodoc:
+        @options ||= DEFAULT_OPTIONS.dup
+      end
+
+      def after_generate_callbacks # :nodoc:
+        @after_generate_callbacks ||= []
+      end
+
+      # Hold configured generators fallbacks. If a plugin developer wants a
+      # generator group to fallback to another group in case of missing generators,
+      # they can add a fallback.
+      #
+      # For example, shoulda is considered a test_framework and is an extension
+      # of test_unit. However, most part of shoulda generators are similar to
+      # test_unit ones.
+      #
+      # Shoulda then can tell generators to search for test_unit generators when
+      # some of them are not available by adding a fallback:
+      #
+      #   Rails::Generators.fallbacks[:shoulda] = :test_unit
+      def fallbacks
+        @fallbacks ||= {}
+      end
+
+      # Configure generators for API only applications. It basically hides
+      # everything that is usually browser related, such as assets and session
+      # migration generators, and completely disable helpers and assets
+      # so generators such as scaffold won't create them.
+      def api_only!
+        hide_namespaces "assets", "helper", "css", "js"
+
+        options[:rails].merge!(
+          api: true,
+          assets: false,
+          helper: false,
+          template_engine: nil
+        )
+
+        options[:mailer] ||= {}
+        options[:mailer][:template_engine] ||= :erb
+      end
+
+      # Returns an array of generator namespaces that are hidden.
+      # Generator namespaces may be hidden for a variety of reasons.
+      # Some are aliased such as "rails:migration" and can be
+      # invoked with the shorter "migration".
+      def hidden_namespaces
+        @hidden_namespaces ||= begin
+          orm      = options[:rails][:orm]
+          test     = options[:rails][:test_framework]
+          template = options[:rails][:template_engine]
+
+          [
+            "rails",
+            "resource_route",
+            "#{orm}:migration",
+            "#{orm}:model",
+            "#{test}:controller",
+            "#{test}:helper",
+            "#{test}:integration",
+            "#{test}:system",
+            "#{test}:mailer",
+            "#{test}:model",
+            "#{test}:scaffold",
+            "#{test}:view",
+            "#{test}:job",
+            "#{template}:controller",
+            "#{template}:scaffold",
+            "#{template}:mailer",
+            "action_text:install",
+            "action_mailbox:install"
+          ]
+        end
+      end
+
+      def hide_namespaces(*namespaces)
+        hidden_namespaces.concat(namespaces)
+      end
+      alias hide_namespace hide_namespaces
+
+      # Show help message with available generators.
+      def help(command = "generate")
+        puts "Usage: rails #{command} GENERATOR [args] [options]"
+        puts
+        puts "General options:"
+        puts "  -h, [--help]     # Print generator's options and usage"
+        puts "  -p, [--pretend]  # Run but do not make any changes"
+        puts "  -f, [--force]    # Overwrite files that already exist"
+        puts "  -s, [--skip]     # Skip files that already exist"
+        puts "  -q, [--quiet]    # Suppress status output"
+        puts
+        puts "Please choose a generator below."
+        puts
+
+        print_generators
+      end
+
+      def public_namespaces
+        lookup!
+        subclasses.map(&:namespace)
+      end
+
+      def print_generators
+        sorted_groups.each { |b, n| print_list(b, n) }
+      end
+
+      def sorted_groups
+        namespaces = public_namespaces
+        namespaces.sort!
+
+        groups = Hash.new { |h, k| h[k] = [] }
+        namespaces.each do |namespace|
+          base = namespace.split(":").first
+          groups[base] << namespace
+        end
+
+        rails = groups.delete("rails")
+        rails.map! { |n| n.delete_prefix("rails:") }
+        rails.delete("app")
+        rails.delete("plugin")
+        rails.delete("encrypted_secrets")
+        rails.delete("encrypted_file")
+        rails.delete("encryption_key_file")
+        rails.delete("master_key")
+        rails.delete("credentials")
+        rails.delete("db:system:change")
+
+        hidden_namespaces.each { |n| groups.delete(n.to_s) }
+
+        [[ "rails", rails ]] + groups.sort.to_a
+      end
+
+      # Rails finds namespaces similar to Thor, it only adds one rule:
+      #
+      # Generators names must end with "_generator.rb". This is required because Rails
+      # looks in load paths and loads the generator just before it's going to be used.
+      #
+      #   find_by_namespace :webrat, :rails, :integration
+      #
+      # Will search for the following generators:
+      #
+      #   "rails:webrat", "webrat:integration", "webrat"
+      #
+      # Notice that "rails:generators:webrat" could be loaded as well, what
+      # Rails looks for is the first and last parts of the namespace.
+      def find_by_namespace(name, base = nil, context = nil) # :nodoc:
+        lookups = []
+        lookups << "#{base}:#{name}"    if base
+        lookups << "#{name}:#{context}" if context
+
+        unless base || context
+          unless name.to_s.include?(?:)
+            lookups << "#{name}:#{name}"
+            lookups << "rails:#{name}"
+          end
+          lookups << "#{name}"
+        end
+
+        lookup(lookups)
+
+        namespaces = subclasses.index_by(&:namespace)
+        lookups.each do |namespace|
+          klass = namespaces[namespace]
+          return klass if klass
+        end
+
+        invoke_fallbacks_for(name, base) || invoke_fallbacks_for(context, name)
+      end
+
+      # Receives a namespace, arguments, and the behavior to invoke the generator.
+      # It's used as the default entry point for generate, destroy, and update
+      # commands.
+      def invoke(namespace, args = ARGV, config = {})
+        names = namespace.to_s.split(":")
+        if klass = find_by_namespace(names.pop, names.any? && names.join(":"))
+          args << "--help" if args.empty? && klass.arguments.any?(&:required?)
+          klass.start(args, config)
+          run_after_generate_callback if config[:behavior] == :invoke
+        else
+          options = sorted_groups.flat_map(&:last)
+          error   = Command::Base::CorrectableError.new("Could not find generator '#{namespace}'.", namespace, options)
+
+          if error.respond_to?(:detailed_message)
+            formatted_message = error.detailed_message
+          else
+            formatted_message = error.message
+          end
+
+          puts <<~MSG
+            #{formatted_message}
+            Run `bin/rails generate --help` for more options.
+          MSG
+        end
+      end
+
+      def add_generated_file(file) # :nodoc:
+        (@@generated_files ||= []) << file
+        file
+      end
+
+      private
+        def print_list(base, namespaces) # :doc:
+          namespaces = namespaces.reject { |n| hidden_namespaces.include?(n) }
+          super
+        end
+
+        # Try fallbacks for the given base.
+        def invoke_fallbacks_for(name, base)
+          return nil unless base && fallbacks[base.to_sym]
+          invoked_fallbacks = []
+
+          Array(fallbacks[base.to_sym]).each do |fallback|
+            next if invoked_fallbacks.include?(fallback)
+            invoked_fallbacks << fallback
+
+            klass = find_by_namespace(name, fallback)
+            return klass if klass
+          end
+
+          nil
+        end
+
+        def command_type # :doc:
+          @command_type ||= "generator"
+        end
+
+        def lookup_paths # :doc:
+          @lookup_paths ||= %w( rails/generators generators )
+        end
+
+        def file_lookup_paths # :doc:
+          @file_lookup_paths ||= [ "{#{lookup_paths.join(',')}}", "**", "*_generator.rb" ]
+        end
+
+        def run_after_generate_callback
+          if defined?(@@generated_files) && !@@generated_files.empty?
+            @after_generate_callbacks.each do |callback|
+              callback.call(@@generated_files)
+            end
+            @@generated_files = []
+          end
+        end
+    end
+  end
+end
diff --git a/info.rb b/info.rb
new file mode 100644
index 0000000000000..5006a81768295
--- /dev/null
+++ b/info.rb
@@ -0,0 +1,105 @@
+# frozen_string_literal: true
+
+require "cgi"
+
+module Rails
+  # This module helps build the runtime properties that are displayed in
+  # Rails::InfoController responses. These include the active Rails version,
+  # Ruby version, Rack version, and so on.
+  module Info
+    mattr_accessor :properties, default: []
+
+    class << @@properties
+      def names
+        map(&:first)
+      end
+
+      def value_for(property_name)
+        if property = assoc(property_name)
+          property.last
+        end
+      end
+    end
+
+    class << self # :nodoc:
+      def property(name, value = nil)
+        value ||= yield
+        properties << [name, value] if value
+      rescue Exception
+      end
+
+      def to_s
+        column_width = properties.names.map(&:length).max
+        info = properties.map do |name, value|
+          value = value.join(", ") if value.is_a?(Array)
+          "%-#{column_width}s   %s" % [name, value]
+        end
+        info.unshift "About your application's environment"
+        info * "\n"
+      end
+
+      alias inspect to_s
+
+      def to_html
+        (+"<table>").tap do |table|
+          properties.each do |(name, value)|
+            table << %(<tr><td class="name">#{CGI.escapeHTML(name.to_s)}</td>)
+            formatted_value = if value.kind_of?(Array)
+              "<ul>" + value.map { |v| "<li>#{CGI.escapeHTML(v.to_s)}</li>" }.join + "</ul>"
+            else
+              CGI.escapeHTML(value.to_s)
+            end
+            table << %(<td class="value">#{formatted_value}</td></tr>)
+          end
+          table << "</table>"
+        end
+      end
+    end
+
+    # The Rails version.
+    property "Rails version" do
+      Rails.version.to_s
+    end
+
+    # The Ruby version and platform, e.g. "2.0.0-p247 (x86_64-darwin12.4.0)".
+    property "Ruby version" do
+      RUBY_DESCRIPTION
+    end
+
+    # The RubyGems version, if it's installed.
+    property "RubyGems version" do
+      Gem::VERSION
+    end
+
+    property "Rack version" do
+      ::Rack.release
+    end
+
+    property "JavaScript Runtime" do
+      ExecJS.runtime.name
+    end
+
+    property "Middleware" do
+      Rails.configuration.middleware.map(&:inspect)
+    end
+
+    # The application's location on the filesystem.
+    property "Application root" do
+      File.expand_path(Rails.root)
+    end
+
+    # The current Rails environment (development, test, or production).
+    property "Environment" do
+      Rails.env
+    end
+
+    # The name of the database adapter for the current environment.
+    property "Database adapter" do
+      ActiveRecord::Base.connection.pool.db_config.adapter
+    end
+
+    property "Database schema version" do
+      ActiveRecord::Base.connection.migration_context.current_version rescue nil
+    end
+  end
+end
diff --git a/info_controller.rb b/info_controller.rb
new file mode 100644
index 0000000000000..eda66c2450370
--- /dev/null
+++ b/info_controller.rb
@@ -0,0 +1,43 @@
+# frozen_string_literal: true
+
+require "rails/application_controller"
+require "action_dispatch/routing/inspector"
+
+class Rails::InfoController < Rails::ApplicationController # :nodoc:
+  prepend_view_path ActionDispatch::DebugView::RESCUES_TEMPLATE_PATH
+  layout -> { request.xhr? ? false : "application" }
+
+  before_action :require_local!
+
+  def index
+    redirect_to action: :routes
+  end
+
+  def properties
+    @info = Rails::Info.to_html
+    @page_title = "Properties"
+  end
+
+  def routes
+    if path = params[:path]
+      path = URI::DEFAULT_PARSER.escape path
+      normalized_path = with_leading_slash path
+      render json: {
+        exact: match_route { |it| it.match normalized_path },
+        fuzzy: match_route { |it| it.spec.to_s.match path }
+      }
+    else
+      @routes_inspector = ActionDispatch::Routing::RoutesInspector.new(_routes.routes)
+      @page_title = "Routes"
+    end
+  end
+
+  private
+    def match_route
+      _routes.routes.filter_map { |route| route.path.spec.to_s if yield route.path }
+    end
+
+    def with_leading_slash(path)
+      ("/" + path).squeeze("/")
+    end
+end
diff --git a/initializable.rb b/initializable.rb
new file mode 100644
index 0000000000000..45547540f1e2b
--- /dev/null
+++ b/initializable.rb
@@ -0,0 +1,95 @@
+# frozen_string_literal: true
+
+require "tsort"
+
+module Rails
+  module Initializable
+    def self.included(base) # :nodoc:
+      base.extend ClassMethods
+    end
+
+    class Initializer
+      attr_reader :name, :block
+
+      def initialize(name, context, options, &block)
+        options[:group] ||= :default
+        @name, @context, @options, @block = name, context, options, block
+      end
+
+      def before
+        @options[:before]
+      end
+
+      def after
+        @options[:after]
+      end
+
+      def belongs_to?(group)
+        @options[:group] == group || @options[:group] == :all
+      end
+
+      def run(*args)
+        @context.instance_exec(*args, &block)
+      end
+
+      def bind(context)
+        return self if @context
+        Initializer.new(@name, context, @options, &block)
+      end
+
+      def context_class
+        @context.class
+      end
+    end
+
+    class Collection < Array
+      include TSort
+
+      alias :tsort_each_node :each
+      def tsort_each_child(initializer, &block)
+        select { |i| i.before == initializer.name || i.name == initializer.after }.each(&block)
+      end
+
+      def +(other)
+        Collection.new(to_a + other.to_a)
+      end
+    end
+
+    def run_initializers(group = :default, *args)
+      return if instance_variable_defined?(:@ran)
+      initializers.tsort_each do |initializer|
+        initializer.run(*args) if initializer.belongs_to?(group)
+      end
+      @ran = true
+    end
+
+    def initializers
+      @initializers ||= self.class.initializers_for(self)
+    end
+
+    module ClassMethods
+      def initializers
+        @initializers ||= Collection.new
+      end
+
+      def initializers_chain
+        initializers = Collection.new
+        ancestors.reverse_each do |klass|
+          next unless klass.respond_to?(:initializers)
+          initializers = initializers + klass.initializers
+        end
+        initializers
+      end
+
+      def initializers_for(binding)
+        Collection.new(initializers_chain.map { |i| i.bind(binding) })
+      end
+
+      def initializer(name, opts = {}, &blk)
+        raise ArgumentError, "A block must be passed when defining an initializer" unless blk
+        opts[:after] ||= initializers.last.name unless initializers.empty? || initializers.find { |i| i.name == opts[:before] }
+        initializers << Initializer.new(name, nil, opts, &blk)
+      end
+    end
+  end
+end
diff --git a/line_statistics b/line_statistics
new file mode 100644
index 0000000000000..d0b3557d7d40a
--- /dev/null
+++ b/line_statistics
@@ -0,0 +1,42 @@
+# Class used to calculate LOC for a provided file list.
+#
+# Example:
+#   files = FileList["lib/active_record/**/*.rb"]
+#   CodeTools::LineStatistics.new(files).print_loc
+module CodeTools
+  class LineStatistics
+
+    # @param files [Array, FileList, Enumerable]
+    # e.g. FileList["lib/active_record/**/*.rb"]
+    def initialize(files)
+      @files = Array(files).compact
+    end
+
+    # Calculates LOC for each file
+    # Outputs each file and a total LOC
+    def print_loc
+      lines, codelines, total_lines, total_codelines = 0, 0, 0, 0
+
+      @files.each do |file_name|
+        next if file_name =~ /vendor/
+        File.open(file_name, 'r') do |f|
+          while line = f.gets
+            lines += 1
+            next if line =~ /^\s*$/
+            next if line =~ /^\s*#/
+            codelines += 1
+          end
+        end
+        puts "L: #{sprintf("%4d", lines)}, LOC #{sprintf("%4d", codelines)} | #{file_name}"
+
+        total_lines     += lines
+        total_codelines += codelines
+
+        lines, codelines = 0, 0
+      end
+
+      puts "Total: Lines #{total_lines}, LOC #{total_codelines}"
+    end
+
+  end
+end
diff --git a/mailers_controller.rb b/mailers_controller.rb
new file mode 100644
index 0000000000000..29586a0f9d098
--- /dev/null
+++ b/mailers_controller.rb
@@ -0,0 +1,99 @@
+# frozen_string_literal: true
+
+require "rails/application_controller"
+
+class Rails::MailersController < Rails::ApplicationController # :nodoc:
+  prepend_view_path ActionDispatch::DebugView::RESCUES_TEMPLATE_PATH
+
+  around_action :set_locale, only: :preview
+  before_action :find_preview, only: :preview
+  before_action :require_local!, unless: :show_previews?
+
+  helper_method :part_query, :locale_query
+
+  content_security_policy(false)
+
+  def index
+    @previews = ActionMailer::Preview.all
+    @page_title = "Mailer Previews"
+  end
+
+  def preview
+    if params[:path] == @preview.preview_name
+      @page_title = "Mailer Previews for #{@preview.preview_name}"
+      render action: "mailer"
+    else
+      @email_action = File.basename(params[:path])
+
+      if @preview.email_exists?(@email_action)
+        @page_title = "Mailer Preview for #{@preview.preview_name}##{@email_action}"
+        @email = @preview.call(@email_action, params)
+
+        if params[:part]
+          part_type = Mime::Type.lookup(params[:part])
+
+          if part = find_part(part_type)
+            response.content_type = part_type
+            render plain: part.respond_to?(:decoded) ? part.decoded : part
+          else
+            raise AbstractController::ActionNotFound, "Email part '#{part_type}' not found in #{@preview.name}##{@email_action}"
+          end
+        else
+          @part = find_preferred_part(request.format, Mime[:html], Mime[:text])
+          render action: "email", layout: false, formats: [:html]
+        end
+      else
+        raise AbstractController::ActionNotFound, "Email '#{@email_action}' not found in #{@preview.name}"
+      end
+    end
+  end
+
+  private
+    def show_previews? # :doc:
+      ActionMailer::Base.show_previews
+    end
+
+    def find_preview # :doc:
+      candidates = []
+      params[:path].to_s.scan(%r{/|$}) { candidates << $` }
+      preview = candidates.detect { |candidate| ActionMailer::Preview.exists?(candidate) }
+
+      if preview
+        @preview = ActionMailer::Preview.find(preview)
+      else
+        raise AbstractController::ActionNotFound, "Mailer preview '#{params[:path]}' not found"
+      end
+    end
+
+    def find_preferred_part(*formats) # :doc:
+      formats.each do |format|
+        if part = @email.find_first_mime_type(format)
+          return part
+        end
+      end
+
+      if formats.any? { |f| @email.mime_type == f }
+        @email
+      end
+    end
+
+    def find_part(format) # :doc:
+      if part = @email.find_first_mime_type(format)
+        part
+      elsif @email.mime_type == format
+        @email
+      end
+    end
+
+    def part_query(mime_type)
+      request.query_parameters.merge(part: mime_type).to_query
+    end
+
+    def locale_query(locale)
+      request.query_parameters.merge(locale: locale).to_query
+    end
+
+    def set_locale(&block)
+      I18n.with_locale(params[:locale] || I18n.default_locale, &block)
+    end
+end
diff --git a/paths.rb b/paths.rb
new file mode 100644
index 0000000000000..e439756e5a571
--- /dev/null
+++ b/paths.rb
@@ -0,0 +1,243 @@
+# frozen_string_literal: true
+
+require "pathname"
+
+module Rails
+  module Paths
+    # This object is an extended hash that behaves as root of the <tt>Rails::Paths</tt> system.
+    # It allows you to collect information about how you want to structure your application
+    # paths through a Hash-like API. It requires you to give a physical path on initialization.
+    #
+    #   root = Root.new "/rails"
+    #   root.add "app/controllers", eager_load: true
+    #
+    # The above command creates a new root object and adds "app/controllers" as a path.
+    # This means we can get a Rails::Paths::Path object back like below:
+    #
+    #   path = root["app/controllers"]
+    #   path.eager_load?               # => true
+    #   path.is_a?(Rails::Paths::Path) # => true
+    #
+    # The +Path+ object is simply an enumerable and allows you to easily add extra paths:
+    #
+    #   path.is_a?(Enumerable) # => true
+    #   path.to_ary.inspect    # => ["app/controllers"]
+    #
+    #   path << "lib/controllers"
+    #   path.to_ary.inspect    # => ["app/controllers", "lib/controllers"]
+    #
+    # Notice that when you add a path using +add+, the path object created already
+    # contains the path with the same path value given to +add+. In some situations,
+    # you may not want this behavior, so you can give <tt>:with</tt> as option.
+    #
+    #   root.add "config/routes", with: "config/routes.rb"
+    #   root["config/routes"].inspect # => ["config/routes.rb"]
+    #
+    # The +add+ method accepts the following options as arguments:
+    # eager_load, autoload, autoload_once, and glob.
+    #
+    # Finally, the +Path+ object also provides a few helpers:
+    #
+    #   root = Root.new "/rails"
+    #   root.add "app/controllers"
+    #
+    #   root["app/controllers"].expanded # => ["/rails/app/controllers"]
+    #   root["app/controllers"].existent # => ["/rails/app/controllers"]
+    #
+    # Check the <tt>Rails::Paths::Path</tt> documentation for more information.
+    class Root
+      attr_accessor :path
+
+      def initialize(path)
+        @path = path
+        @root = {}
+      end
+
+      def []=(path, value)
+        glob = self[path] ? self[path].glob : nil
+        add(path, with: value, glob: glob)
+      end
+
+      def add(path, options = {})
+        with = Array(options.fetch(:with, path))
+        @root[path] = Path.new(self, path, with, options)
+      end
+
+      def [](path)
+        @root[path]
+      end
+
+      def values
+        @root.values
+      end
+
+      def keys
+        @root.keys
+      end
+
+      def values_at(*list)
+        @root.values_at(*list)
+      end
+
+      def all_paths
+        values.tap(&:uniq!)
+      end
+
+      def autoload_once
+        filter_by(&:autoload_once?)
+      end
+
+      def eager_load
+        filter_by(&:eager_load?)
+      end
+
+      def autoload_paths
+        filter_by(&:autoload?)
+      end
+
+      def load_paths
+        filter_by(&:load_path?)
+      end
+
+    private
+      def filter_by(&block)
+        all_paths.find_all(&block).flat_map { |path|
+          paths = path.existent
+          paths - path.children.flat_map { |p| yield(p) ? [] : p.existent }
+        }.uniq
+      end
+    end
+
+    class Path
+      include Enumerable
+
+      attr_accessor :glob
+
+      def initialize(root, current, paths, options = {})
+        @paths   = paths
+        @current = current
+        @root    = root
+        @glob    = options[:glob]
+        @exclude = options[:exclude]
+
+        options[:autoload_once] ? autoload_once! : skip_autoload_once!
+        options[:eager_load]    ? eager_load!    : skip_eager_load!
+        options[:autoload]      ? autoload!      : skip_autoload!
+        options[:load_path]     ? load_path!     : skip_load_path!
+      end
+
+      def absolute_current # :nodoc:
+        File.expand_path(@current, @root.path)
+      end
+
+      def children
+        keys = @root.keys.find_all { |k|
+          k.start_with?(@current) && k != @current
+        }
+        @root.values_at(*keys.sort)
+      end
+
+      def first
+        expanded.first
+      end
+
+      def last
+        expanded.last
+      end
+
+      %w(autoload_once eager_load autoload load_path).each do |m|
+        class_eval <<-RUBY, __FILE__, __LINE__ + 1
+          def #{m}!        # def eager_load!
+            @#{m} = true   #   @eager_load = true
+          end              # end
+                           #
+          def skip_#{m}!   # def skip_eager_load!
+            @#{m} = false  #   @eager_load = false
+          end              # end
+                           #
+          def #{m}?        # def eager_load?
+            @#{m}          #   @eager_load
+          end              # end
+        RUBY
+      end
+
+      def each(&block)
+        @paths.each(&block)
+      end
+
+      def <<(path)
+        @paths << path
+      end
+      alias :push :<<
+
+      def concat(paths)
+        @paths.concat paths
+      end
+
+      def unshift(*paths)
+        @paths.unshift(*paths)
+      end
+
+      def to_ary
+        @paths
+      end
+
+      def paths
+        raise "You need to set a path root" unless @root.path
+
+        map do |p|
+          Pathname.new(@root.path).join(p)
+        end
+      end
+
+      def extensions # :nodoc:
+        $1.split(",") if @glob =~ /\{([\S]+)\}/
+      end
+
+      # Expands all paths against the root and return all unique values.
+      def expanded
+        raise "You need to set a path root" unless @root.path
+        result = []
+
+        each do |path|
+          path = File.expand_path(path, @root.path)
+
+          if @glob && File.directory?(path)
+            result.concat files_in(path)
+          else
+            result << path
+          end
+        end
+
+        result.uniq!
+        result
+      end
+
+      # Returns all expanded paths but only if they exist in the filesystem.
+      def existent
+        expanded.select do |f|
+          does_exist = File.exist?(f)
+
+          if !does_exist && File.symlink?(f)
+            raise "File #{f.inspect} is a symlink that does not point to a valid file"
+          end
+          does_exist
+        end
+      end
+
+      def existent_directories
+        expanded.select { |d| File.directory?(d) }
+      end
+
+      alias to_a expanded
+
+      private
+        def files_in(path)
+          files = Dir.glob(@glob, base: path)
+          files -= @exclude if @exclude
+          files.map! { |file| File.join(path, file) }
+          files.sort
+        end
+    end
+  end
+end
diff --git a/profile b/profile
new file mode 100644
index 0000000000000..d38ba1dd8482f
--- /dev/null
+++ b/profile
@@ -0,0 +1,137 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+# Profile require calls giving information about the time and the files that are called
+# when loading the provided file.
+#
+# Example:
+#   tools/profile activesupport/lib/active_support.rb [ruby-prof mode] [ruby-prof printer]
+ENV["NO_RELOAD"] ||= "1"
+ENV["RAILS_ENV"] ||= "development"
+
+module CodeTools
+  class Profiler
+    Error = Class.new(StandardError)
+
+    attr_reader :path, :mode
+    def initialize(path, mode = nil)
+      assert_ruby_file_exists(path)
+      @path, @mode = path, mode
+      require "benchmark"
+    end
+
+    def profile_requires
+      GC.start
+      before_rss = `ps -o rss= -p #{Process.pid}`.to_i
+
+      if mode
+        require "ruby-prof"
+        RubyProf.measure_mode = RubyProf.const_get(mode.upcase)
+        RubyProf.start
+      else
+        Object.instance_eval { include RequireProfiler }
+      end
+
+      elapsed = Benchmark.realtime { require path }
+      results = RubyProf.stop if mode
+
+      GC.start
+      after_rss = `ps -o rss= -p #{Process.pid}`.to_i
+
+      if mode
+        if printer = ARGV.shift
+          puts "RubyProf outputting to stderr with printer #{printer}"
+          RubyProf.const_get("#{printer.to_s.classify}Printer").new(results).print($stdout)
+        elsif RubyProf.const_defined?(:CallStackPrinter)
+          filename = "#{File.basename(path, '.rb')}.#{mode}.html"
+          puts "RubyProf outputting to #{filename}"
+          File.open(filename, "w") do |out|
+            RubyProf::CallStackPrinter.new(results).print(out)
+          end
+        else
+          filename = "#{File.basename(path, '.rb')}.#{mode}.callgrind"
+          puts "RubyProf outputting to #{filename}"
+          File.open(filename, "w") do |out|
+            RubyProf::CallTreePrinter.new(results).print(out)
+          end
+        end
+      end
+
+      RequireProfiler.stats.each do |file, depth, sec|
+        if sec
+          puts "%8.1f ms  %s%s" % [sec * 1000, " " * depth, file]
+        else
+          puts "#{' ' * (13 + depth)}#{file}"
+        end
+      end
+      puts "%8.1f ms  %d KB RSS" % [elapsed * 1000, after_rss - before_rss]
+    end
+
+    private
+      def assert_ruby_file_exists(path)
+        fail Error.new("No such file") unless File.exist?(path)
+        fail Error.new("#{path} is a directory") if File.directory?(path)
+        ruby_extension = File.extname(path) == ".rb"
+        ruby_executable = File.open(path, "rb") { |f| f.readline } =~ [/\A#!.*ruby/]
+        fail Error.new("Not a ruby file") unless ruby_extension || ruby_executable
+      end
+
+      module RequireProfiler
+        private
+          def require(file, *args) RequireProfiler.profile(file) { super } end
+          def load(file, *args) RequireProfiler.profile(file) { super } end
+
+          @depth, @stats = 0, []
+          class << self
+            attr_accessor :depth
+            attr_accessor :stats
+
+            def profile(file)
+              stats << [file, depth]
+              self.depth += 1
+              result = nil
+              elapsed = Benchmark.realtime { result = yield }
+              self.depth -= 1
+              stats.pop if stats.last.first == file
+              stats << [file, depth, elapsed] if result
+              result
+            end
+          end
+      end
+  end
+end
+# ruby-prof printer name causes the third arg to be sent :classify
+#   which is probably overkill if you already know the name of the ruby-prof
+#   printer you want to use, e.g. Graph
+begin
+  require "active_support/inflector"
+  require "active_support/core_ext/string/inflections"
+rescue LoadError
+  STDERR.puts $!.message
+  class String
+    # File activesupport/lib/active_support/inflector/methods.rb, line 150
+    def classify
+      # strip out any leading schema name
+      camelize(sub(/.*\./, ""))
+    end
+    # File activesupport/lib/active_support/inflector/methods.rb, line 68
+    def camelize(uppercase_first_letter = true)
+      string = self
+      if uppercase_first_letter
+        string = string.sub(/^[a-z\d]*/) { |match| match.capitalize }
+      else
+        string = string.sub(/^(?:(?=\b|[A-Z_])|\w)/) { |match| match.downcase }
+      end
+      string.gsub(/(?:_|(\/))([a-z\d]*)/) { "#{$1}#{$2.capitalize}" }.gsub("/", "::")
+    end
+  end
+end
+if $0 == __FILE__
+  if (filename = ARGV.shift)
+    path = File.expand_path(filename)
+    mode = ARGV.shift
+    CodeTools::Profiler.new(path, mode).profile_requires
+  else
+    STDERR.puts "No file path entered. Usage is tools/profile path/to/file.rb [ruby-prof mode] [ruby-prof printer]"
+  end
+end
diff --git a/qunit-selenium-runner.rb b/qunit-selenium-runner.rb
new file mode 100644
index 0000000000000..8703301083924
--- /dev/null
+++ b/qunit-selenium-runner.rb
@@ -0,0 +1,33 @@
+# frozen_string_literal: true
+
+require "webdrivers"
+require_relative "test_run"
+
+driver = if ARGV[1]
+  capability = ::Selenium::WebDriver::Remote::Capabilities.chrome
+
+  ::Selenium::WebDriver.for(:remote, url: ARGV[1], capabilities: [capability])
+else
+  driver_options = Selenium::WebDriver::Chrome::Options.new
+  driver_options.add_argument("--headless")
+  driver_options.add_argument("--disable-gpu")
+  driver_options.add_argument("--no-sandbox")
+
+  ::Selenium::WebDriver.for(:chrome, capabilities: [driver_options])
+end
+
+driver.get(ARGV[0])
+
+result = TestRun.new(driver).tap do |run|
+  ::Selenium::WebDriver::Wait.new(timeout: 60).until do
+    run.completed?
+  end
+end.result
+
+driver.quit
+
+puts "Time: #{result.duration} seconds, Total: #{result.assertions[:total]}, Passed: #{result.assertions[:passed]}, Failed: #{result.assertions[:failed]}"
+if result.tests[:failed] > 0
+  puts "Qunit output follows. Look for lines that have failures, e.g. (1, n, n) - those are your failing lines\r\n\r\n#{result.raw_output}"
+end
+exit(result.tests[:failed] > 0 ? 1 : 0)
diff --git a/rack.rb b/rack.rb
new file mode 100644
index 0000000000000..579fb25cc4bd4
--- /dev/null
+++ b/rack.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: true
+
+module Rails
+  module Rack
+    autoload :Logger, "rails/rack/logger"
+  end
+end
diff --git a/rails b/rails
new file mode 100644
index 0000000000000..79af4db6b676f
--- /dev/null
+++ b/rails
@@ -0,0 +1,10 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+git_path = File.expand_path("../../.git", __dir__)
+
+if File.exist?(git_path)
+  railties_path = File.expand_path("../lib", __dir__)
+  $:.unshift(railties_path)
+end
+require "rails/cli"
diff --git a/rails.rb b/rails.rb
new file mode 100644
index 0000000000000..8bf112cbd0dd6
--- /dev/null
+++ b/rails.rb
@@ -0,0 +1,127 @@
+# frozen_string_literal: true
+
+require "rails/ruby_version_check"
+
+require "pathname"
+
+require "active_support"
+require "active_support/core_ext/kernel/reporting"
+require "active_support/core_ext/module/delegation"
+require "active_support/core_ext/array/extract_options"
+require "active_support/core_ext/object/blank"
+
+require "rails/application"
+require "rails/version"
+
+require "active_support/railtie"
+require "action_dispatch/railtie"
+
+# UTF-8 is the default internal and external encoding.
+silence_warnings do
+  Encoding.default_external = Encoding::UTF_8
+  Encoding.default_internal = Encoding::UTF_8
+end
+
+module Rails
+  extend ActiveSupport::Autoload
+  extend ActiveSupport::Benchmarkable
+
+  autoload :Info
+  autoload :InfoController
+  autoload :MailersController
+  autoload :WelcomeController
+
+  class << self
+    @application = @app_class = nil
+
+    attr_writer :application
+    attr_accessor :app_class, :cache, :logger
+    def application
+      @application ||= (app_class.instance if app_class)
+    end
+
+    delegate :initialize!, :initialized?, to: :application
+
+    # The Configuration instance used to configure the Rails environment
+    def configuration
+      application.config
+    end
+
+    def backtrace_cleaner
+      @backtrace_cleaner ||= begin
+        # Relies on Active Support, so we have to lazy load to postpone definition until Active Support has been loaded
+        require "rails/backtrace_cleaner"
+        Rails::BacktraceCleaner.new
+      end
+    end
+
+    # Returns a Pathname object of the current Rails project,
+    # otherwise it returns +nil+ if there is no project:
+    #
+    #   Rails.root
+    #     # => #<Pathname:/Users/someuser/some/path/project>
+    def root
+      application && application.config.root
+    end
+
+    # Returns the current Rails environment.
+    #
+    #   Rails.env # => "development"
+    #   Rails.env.development? # => true
+    #   Rails.env.production? # => false
+    def env
+      @_env ||= ActiveSupport::EnvironmentInquirer.new(ENV["RAILS_ENV"].presence || ENV["RACK_ENV"].presence || "development")
+    end
+
+    # Sets the Rails environment.
+    #
+    #   Rails.env = "staging" # => "staging"
+    def env=(environment)
+      @_env = ActiveSupport::EnvironmentInquirer.new(environment)
+    end
+
+    # Returns the ActiveSupport::ErrorReporter of the current Rails project,
+    # otherwise it returns +nil+ if there is no project.
+    #
+    #   Rails.error.handle(IOError) do
+    #     # ...
+    #   end
+    #   Rails.error.report(error)
+    def error
+      application && application.executor.error_reporter
+    end
+
+    # Returns all Rails groups for loading based on:
+    #
+    # * The Rails environment;
+    # * The environment variable RAILS_GROUPS;
+    # * The optional envs given as argument and the hash with group dependencies;
+    #
+    #  Rails.groups assets: [:development, :test]
+    #  # => [:default, "development", :assets] for Rails.env == "development"
+    #  # => [:default, "production"]           for Rails.env == "production"
+    def groups(*groups)
+      hash = groups.extract_options!
+      env = Rails.env
+      groups.unshift(:default, env)
+      groups.concat ENV["RAILS_GROUPS"].to_s.split(",")
+      groups.concat hash.map { |k, v| k if v.map(&:to_s).include?(env) }
+      groups.compact!
+      groups.uniq!
+      groups
+    end
+
+    # Returns a Pathname object of the public folder of the current
+    # Rails project, otherwise it returns +nil+ if there is no project:
+    #
+    #   Rails.public_path
+    #     # => #<Pathname:/Users/someuser/some/path/project/public>
+    def public_path
+      application && Pathname.new(application.paths["public"].first)
+    end
+
+    def autoloaders
+      application.autoloaders
+    end
+  end
+end
diff --git a/railtie.rb b/railtie.rb
new file mode 100644
index 0000000000000..f8347e56f5c6e
--- /dev/null
+++ b/railtie.rb
@@ -0,0 +1,303 @@
+# frozen_string_literal: true
+
+require "rails/initializable"
+require "active_support/descendants_tracker"
+require "active_support/inflector"
+require "active_support/core_ext/module/introspection"
+require "active_support/core_ext/module/delegation"
+
+module Rails
+  # <tt>Rails::Railtie</tt> is the core of the Rails framework and provides
+  # several hooks to extend Rails and/or modify the initialization process.
+  #
+  # Every major component of Rails (Action Mailer, Action Controller, Active
+  # Record, etc.) implements a railtie. Each of them is responsible for their
+  # own initialization. This makes Rails itself absent of any component hooks,
+  # allowing other components to be used in place of any of the Rails defaults.
+  #
+  # Developing a Rails extension does _not_ require implementing a railtie, but
+  # if you need to interact with the Rails framework during or after boot, then
+  # a railtie is needed.
+  #
+  # For example, an extension doing any of the following would need a railtie:
+  #
+  # * creating initializers
+  # * configuring a Rails framework for the application, like setting a generator
+  # * adding <tt>config.*</tt> keys to the environment
+  # * setting up a subscriber with ActiveSupport::Notifications
+  # * adding Rake tasks
+  #
+  # == Creating a Railtie
+  #
+  # To extend Rails using a railtie, create a subclass of <tt>Rails::Railtie</tt>.
+  # This class must be loaded during the Rails boot process, and is conventionally
+  # called <tt>MyNamespace::Railtie</tt>.
+  #
+  # The following example demonstrates an extension which can be used with or
+  # without Rails.
+  #
+  #   # lib/my_gem/railtie.rb
+  #   module MyGem
+  #     class Railtie < Rails::Railtie
+  #     end
+  #   end
+  #
+  #   # lib/my_gem.rb
+  #   require "my_gem/railtie" if defined?(Rails::Railtie)
+  #
+  # == Initializers
+  #
+  # To add an initialization step to the Rails boot process from your railtie, just
+  # define the initialization code with the +initializer+ macro:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     initializer "my_railtie.configure_rails_initialization" do
+  #       # some initialization behavior
+  #     end
+  #   end
+  #
+  # If specified, the block can also receive the application object, in case you
+  # need to access some application-specific configuration, like middleware:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     initializer "my_railtie.configure_rails_initialization" do |app|
+  #       app.middleware.use MyRailtie::Middleware
+  #     end
+  #   end
+  #
+  # Finally, you can also pass <tt>:before</tt> and <tt>:after</tt> as options to
+  # +initializer+, in case you want to couple it with a specific step in the
+  # initialization process.
+  #
+  # == Configuration
+  #
+  # Railties can access a config object which contains configuration shared by all
+  # railties and the application:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     # Customize the ORM
+  #     config.app_generators.orm :my_railtie_orm
+  #
+  #     # Add a to_prepare block which is executed once in production
+  #     # and before each request in development.
+  #     config.to_prepare do
+  #       MyRailtie.setup!
+  #     end
+  #   end
+  #
+  # == Loading Rake Tasks and Generators
+  #
+  # If your railtie has Rake tasks, you can tell Rails to load them through the method
+  # +rake_tasks+:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     rake_tasks do
+  #       load "path/to/my_railtie.tasks"
+  #     end
+  #   end
+  #
+  # By default, Rails loads generators from your load path. However, if you want to place
+  # your generators at a different location, you can specify in your railtie a block which
+  # will load them during normal generators lookup:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     generators do
+  #       require "path/to/my_railtie_generator"
+  #     end
+  #   end
+  #
+  # Since filenames on the load path are shared across gems, be sure that files you load
+  # through a railtie have unique names.
+  #
+  # == Run another program when the Rails server starts
+  #
+  # In development, it's very usual to have to run another process next to the Rails Server. In example
+  # you might want to start the Webpack or React server. Or maybe you need to run your job scheduler process
+  # like Sidekiq. This is usually done by opening a new shell and running the program from here.
+  #
+  # Rails allow you to specify a +server+ block which will get called when a Rails server starts.
+  # This way, your users don't need to remember to have to open a new shell and run another program, making
+  # this less confusing for everyone.
+  # It can be used like this:
+  #
+  #   class MyRailtie < Rails::Railtie
+  #     server do
+  #       WebpackServer.start
+  #     end
+  #   end
+  #
+  # == Application and Engine
+  #
+  # An engine is nothing more than a railtie with some initializers already set. And since
+  # Rails::Application is an engine, the same configuration described here can be
+  # used in both.
+  #
+  # Be sure to look at the documentation of those specific classes for more information.
+  class Railtie
+    autoload :Configuration, "rails/railtie/configuration"
+
+    extend ActiveSupport::DescendantsTracker
+    include Initializable
+
+    ABSTRACT_RAILTIES = %w(Rails::Railtie Rails::Engine Rails::Application)
+
+    class << self
+      private :new
+      delegate :config, to: :instance
+
+      def subclasses
+        super.reject(&:abstract_railtie?).sort
+      end
+
+      def rake_tasks(&blk)
+        register_block_for(:rake_tasks, &blk)
+      end
+
+      def console(&blk)
+        register_block_for(:load_console, &blk)
+      end
+
+      def runner(&blk)
+        register_block_for(:runner, &blk)
+      end
+
+      def generators(&blk)
+        register_block_for(:generators, &blk)
+      end
+
+      def server(&blk)
+        register_block_for(:server, &blk)
+      end
+
+      def abstract_railtie?
+        ABSTRACT_RAILTIES.include?(name)
+      end
+
+      def railtie_name(name = nil)
+        @railtie_name = name.to_s if name
+        @railtie_name ||= generate_railtie_name(self.name)
+      end
+
+      # Since Rails::Railtie cannot be instantiated, any methods that call
+      # +instance+ are intended to be called only on subclasses of a Railtie.
+      def instance
+        @instance ||= new
+      end
+
+      # Allows you to configure the railtie. This is the same method seen in
+      # Railtie::Configurable, but this module is no longer required for all
+      # subclasses of Railtie so we provide the class method here.
+      def configure(&block)
+        instance.configure(&block)
+      end
+
+      def <=>(other) # :nodoc:
+        load_index <=> other.load_index
+      end
+
+      def inherited(subclass)
+        subclass.increment_load_index
+        super
+      end
+
+      protected
+        attr_reader :load_index
+
+        def increment_load_index
+          @@load_counter ||= 0
+          @load_index = (@@load_counter += 1)
+        end
+
+      private
+        def generate_railtie_name(string)
+          ActiveSupport::Inflector.underscore(string).tr("/", "_")
+        end
+
+        def respond_to_missing?(name, _)
+          return super if abstract_railtie?
+
+          instance.respond_to?(name) || super
+        end
+
+        # If the class method does not have a method, then send the method call
+        # to the Railtie instance.
+        def method_missing(name, *args, &block)
+          if !abstract_railtie? && instance.respond_to?(name)
+            instance.public_send(name, *args, &block)
+          else
+            super
+          end
+        end
+        ruby2_keywords(:method_missing)
+
+        # receives an instance variable identifier, set the variable value if is
+        # blank and append given block to value, which will be used later in
+        # `#each_registered_block(type, &block)`
+        def register_block_for(type, &blk)
+          var_name = "@#{type}"
+          blocks = instance_variable_defined?(var_name) ? instance_variable_get(var_name) : instance_variable_set(var_name, [])
+          blocks << blk if blk
+          blocks
+        end
+    end
+
+    delegate :railtie_name, to: :class
+
+    def initialize # :nodoc:
+      if self.class.abstract_railtie?
+        raise "#{self.class.name} is abstract, you cannot instantiate it directly."
+      end
+    end
+
+    def inspect # :nodoc:
+      "#<#{self.class.name}>"
+    end
+
+    def configure(&block) # :nodoc:
+      instance_eval(&block)
+    end
+
+    # This is used to create the <tt>config</tt> object on Railties, an instance of
+    # Railtie::Configuration, that is used by Railties and Application to store
+    # related configuration.
+    def config
+      @config ||= Railtie::Configuration.new
+    end
+
+    def railtie_namespace # :nodoc:
+      @railtie_namespace ||= self.class.module_parents.detect { |n| n.respond_to?(:railtie_namespace) }
+    end
+
+    protected
+      def run_console_blocks(app) # :nodoc:
+        each_registered_block(:console) { |block| block.call(app) }
+      end
+
+      def run_generators_blocks(app) # :nodoc:
+        each_registered_block(:generators) { |block| block.call(app) }
+      end
+
+      def run_runner_blocks(app) # :nodoc:
+        each_registered_block(:runner) { |block| block.call(app) }
+      end
+
+      def run_tasks_blocks(app) # :nodoc:
+        extend Rake::DSL
+        each_registered_block(:rake_tasks) { |block| instance_exec(app, &block) }
+      end
+
+      def run_server_blocks(app) # :nodoc:
+        each_registered_block(:server) { |block| block.call(app) }
+      end
+
+    private
+      # run `&block` in every registered block in `#register_block_for`
+      def each_registered_block(type, &block)
+        klass = self.class
+        while klass.respond_to?(type)
+          klass.public_send(type).each(&block)
+          klass = klass.superclass
+        end
+      end
+  end
+end
diff --git a/release.rb b/release.rb
new file mode 100644
index 0000000000000..345ad7ea02ed2
--- /dev/null
+++ b/release.rb
@@ -0,0 +1,333 @@
+# frozen_string_literal: true
+
+# Order dependent. E.g. Action Mailbox depends on Active Record so it should be after.
+FRAMEWORKS = %w(
+  activesupport
+  activemodel
+  activerecord
+  actionview
+  actionpack
+  activejob
+  actionmailer
+  actioncable
+  activestorage
+  actionmailbox
+  actiontext
+  railties
+)
+FRAMEWORK_NAMES = Hash.new { |h, k| k.split(/(?<=active|action)/).map(&:capitalize).join(" ") }
+
+root    = File.expand_path("..", __dir__)
+version = File.read("#{root}/RAILS_VERSION").strip
+tag     = "v#{version}"
+
+directory "pkg"
+
+# This "npm-ifies" the current version number
+# With npm, versions such as "5.0.0.rc1" or "5.0.0.beta1.1" are not compliant with its
+# versioning system, so they must be transformed to "5.0.0-rc1" and "5.0.0-beta1-1" respectively.
+
+# "5.0.1"     --> "5.0.1"
+# "5.0.1.1"   --> "5.0.1-1" *
+# "5.0.0.rc1" --> "5.0.0-rc1"
+#
+# * This makes it a prerelease. That's bad, but we haven't come up with
+# a better solution at the moment.
+npm_version = version.gsub(/\./).with_index { |s, i| i >= 2 ? "-" : s }
+
+(FRAMEWORKS + ["rails"]).each do |framework|
+  namespace framework do
+    gem     = "pkg/#{framework}-#{version}.gem"
+    gemspec = "#{framework}.gemspec"
+
+    task :clean do
+      rm_f gem
+    end
+
+    task :update_versions do
+      glob = root.dup
+      if framework == "rails"
+        glob << "/version.rb"
+      else
+        glob << "/#{framework}/lib/*"
+        glob << "/gem_version.rb"
+      end
+
+      file = Dir[glob].first
+      ruby = File.read(file)
+
+      major, minor, tiny, pre = version.split(".", 4)
+      pre = pre ? pre.inspect : "nil"
+
+      ruby.gsub!(/^(\s*)MAJOR(\s*)= .*?$/, "\\1MAJOR = #{major}")
+      raise "Could not insert MAJOR in #{file}" unless $1
+
+      ruby.gsub!(/^(\s*)MINOR(\s*)= .*?$/, "\\1MINOR = #{minor}")
+      raise "Could not insert MINOR in #{file}" unless $1
+
+      ruby.gsub!(/^(\s*)TINY(\s*)= .*?$/, "\\1TINY  = #{tiny}")
+      raise "Could not insert TINY in #{file}" unless $1
+
+      ruby.gsub!(/^(\s*)PRE(\s*)= .*?$/, "\\1PRE   = #{pre}")
+      raise "Could not insert PRE in #{file}" unless $1
+
+      File.open(file, "w") { |f| f.write ruby }
+
+      require "json"
+      if File.exist?("#{framework}/package.json") && JSON.parse(File.read("#{framework}/package.json"))["version"] != npm_version
+        Dir.chdir("#{framework}") do
+          if sh "which npm"
+            sh "npm version #{npm_version} --no-git-tag-version"
+          else
+            raise "You must have npm installed to release Rails."
+          end
+        end
+      end
+    end
+
+    task gem => %w(update_versions pkg) do
+      cmd = ""
+      cmd += "cd #{framework} && " unless framework == "rails"
+      cmd += "bundle exec rake package && " unless framework == "rails"
+      cmd += "gem build #{gemspec} && mv #{framework}-#{version}.gem #{root}/pkg/"
+      sh cmd
+    end
+
+    task build: [:clean, gem]
+    task install: :build do
+      sh "gem install --pre #{gem}"
+    end
+
+    task push: :build do
+      otp = ""
+      begin
+        otp = " --otp " + `ykman oath accounts code -s rubygems.org`.chomp
+      rescue
+        # User doesn't have ykman
+      end
+
+      sh "gem push #{gem}#{otp}"
+
+      if File.exist?("#{framework}/package.json")
+        Dir.chdir("#{framework}") do
+          npm_tag = /[a-z]/.match?(version) ? "pre" : "latest"
+          npm_otp = ""
+          begin
+            npm_otp = " --otp " + `ykman oath accounts code -s npmjs.com`.chomp
+          rescue
+            # User doesn't have ykman
+          end
+
+          sh "npm publish --tag #{npm_tag}#{npm_otp}"
+        end
+      end
+    end
+  end
+end
+
+namespace :changelog do
+  task :header do
+    (FRAMEWORKS + ["guides"]).each do |fw|
+      require "date"
+      fname = File.join fw, "CHANGELOG.md"
+      current_contents = File.read(fname)
+
+      header = "## Rails #{version} (#{Date.today.strftime('%B %d, %Y')}) ##\n\n"
+      header += "*   No changes.\n\n\n" if current_contents.start_with?("##")
+      contents = header + current_contents
+      File.write(fname, contents)
+    end
+  end
+
+  task :release_date do
+    (FRAMEWORKS + ["guides"]).each do |fw|
+      require "date"
+      replace = "## Rails #{version} (#{Date.today.strftime('%B %d, %Y')}) ##\n"
+      fname = File.join fw, "CHANGELOG.md"
+
+      contents = File.read(fname).sub(/^(## Rails .*)\n/, replace)
+      File.write(fname, contents)
+    end
+  end
+
+  task :release_summary, [:base_release, :release] do |_, args|
+    release_regexp = args[:base_release] ? Regexp.escape(args[:base_release]) : /\d+\.\d+\.\d+/
+
+    puts args[:release]
+
+    FRAMEWORKS.each do |fw|
+      puts "## #{FRAMEWORK_NAMES[fw]}"
+      fname    = File.join fw, "CHANGELOG.md"
+      contents = File.readlines fname
+      contents.shift
+      changes = []
+      until contents.first =~ /^## Rails #{release_regexp}.*$/ ||
+          contents.first =~ /^Please check.*for previous changes\.$/ ||
+          contents.empty?
+        changes << contents.shift
+      end
+
+      puts changes.join
+      puts
+    end
+  end
+end
+
+namespace :all do
+  task build: FRAMEWORKS.map { |f| "#{f}:build"           } + ["rails:build"]
+  task update_versions: FRAMEWORKS.map { |f| "#{f}:update_versions" } + ["rails:update_versions"]
+  task install: FRAMEWORKS.map { |f| "#{f}:install"         } + ["rails:install"]
+  task push: FRAMEWORKS.map { |f| "#{f}:push"            } + ["rails:push"]
+
+  task :ensure_clean_state do
+    unless `git status -s | grep -v 'RAILS_VERSION\\|CHANGELOG\\|Gemfile.lock\\|package.json\\|version.rb\\|tasks/release.rb'`.strip.empty?
+      abort "[ABORTING] `git status` reports a dirty tree. Make sure all changes are committed"
+    end
+
+    unless ENV["SKIP_TAG"] || `git tag | grep '^#{tag}$'`.strip.empty?
+      abort "[ABORTING] `git tag` shows that #{tag} already exists. Has this version already\n"\
+            "           been released? Git tagging can be skipped by setting SKIP_TAG=1"
+    end
+  end
+
+  task verify: :install do
+    require "tmpdir"
+
+    cd Dir.tmpdir
+    app_name = "verify-#{version}-#{Time.now.to_i}"
+    sh "rails _#{version}_ new #{app_name} --skip-bundle" # Generate with the right version.
+    cd app_name
+
+    substitute = -> (file_name, regex, replacement) do
+      File.write(file_name, File.read(file_name).sub(regex, replacement))
+    end
+
+    # Replace the generated gemfile entry with the exact version.
+    substitute.call("Gemfile", /^gem 'rails.*/, "gem 'rails', '#{version}'")
+    substitute.call("Gemfile", /^# gem 'image_processing/, "gem 'image_processing")
+    sh "bundle"
+    sh "rails action_mailbox:install"
+    sh "rails action_text:install"
+
+    sh "rails generate scaffold user name description:text admin:boolean"
+    sh "rails db:migrate"
+
+    # Replace the generated gemfile entry with the exact version.
+    substitute.call("app/models/user.rb", /end\n\z/, <<~CODE)
+        has_one_attached :avatar
+        has_rich_text :description
+      end
+    CODE
+
+    substitute.call("app/views/users/_form.html.erb", /text_area :description %>\n  <\/div>/, <<~CODE)
+      rich_text_area :description %>\n  </div>
+
+      <div class="field">
+        Avatar: <%= form.file_field :avatar %>
+      </div>
+    CODE
+
+    substitute.call("app/views/users/show.html.erb", /description %>\n<\/p>/, <<~CODE)
+      description %>\n</p>
+
+      <p>
+        <% if @user.avatar.attached? -%>
+          <%= image_tag @user.avatar.representation(resize_to_limit: [500, 500]) %>
+        <% end -%>
+      </p>
+    CODE
+
+    # Permit the avatar param.
+    substitute.call("app/controllers/users_controller.rb", /:admin/, ":admin, :avatar")
+
+    if ENV["EDITOR"]
+      `#{ENV["EDITOR"]} #{File.expand_path(app_name)}`
+    end
+
+    puts "Booting a Rails server. Verify the release by:"
+    puts
+    puts "- Seeing the correct release number on the root page"
+    puts "- Viewing /users"
+    puts "- Creating a user"
+    puts "- Updating a user (e.g. disable the admin flag)"
+    puts "- Deleting a user on /users"
+    puts "- Whatever else you want."
+    begin
+      sh "rails server"
+    rescue Interrupt
+      # Server passes along interrupt. Prevent halting verify task.
+    end
+  end
+
+  task :bundle do
+    sh "bundle check"
+  end
+
+  task :commit do
+    unless `git status -s`.strip.empty?
+      File.open("pkg/commit_message.txt", "w") do |f|
+        f.puts "# Preparing for #{version} release\n"
+        f.puts
+        f.puts "# UNCOMMENT THE LINE ABOVE TO APPROVE THIS COMMIT"
+      end
+
+      sh "git add . && git commit --verbose --template=pkg/commit_message.txt"
+      rm_f "pkg/commit_message.txt"
+    end
+  end
+
+  task :tag do
+    sh "git tag -s -m '#{tag} release' #{tag}"
+    sh "git push --tags"
+  end
+
+  task prep_release: %w(ensure_clean_state build bundle commit)
+
+  task release: %w(prep_release tag push)
+end
+
+module Announcement
+  class Version
+    def initialize(version)
+      @version, @gem_version = version, Gem::Version.new(version)
+    end
+
+    def to_s
+      @version
+    end
+
+    def previous
+      @gem_version.segments[0, 3].tap { |v| v[2] -= 1 }.join(".")
+    end
+
+    def major_or_security?
+      @gem_version.segments[2].zero? || @gem_version.segments[3].is_a?(Integer)
+    end
+
+    def rc?
+      @version =~ /rc/
+    end
+  end
+end
+
+task :announce do
+  Dir.chdir("pkg/") do
+    versions = ENV["VERSIONS"] ? ENV["VERSIONS"].split(",") : [ version ]
+    versions = versions.sort.map { |v| Announcement::Version.new(v) }
+
+    raise "Only valid for patch releases" if versions.any?(&:major_or_security?)
+
+    if versions.any?(&:rc?)
+      require "date"
+      future_date = Date.today + 5
+      future_date += 1 while future_date.saturday? || future_date.sunday?
+
+      github_user = `git config github.user`.chomp
+    end
+
+    require "erb"
+    template = File.read("../tasks/release_announcement_draft.erb")
+
+    puts ERB.new(template, trim_mode: "<>").result(binding)
+  end
+end
diff --git a/release_announcement_draft.erb b/release_announcement_draft.erb
new file mode 100644
index 0000000000000..19c4b14cd47f8
--- /dev/null
+++ b/release_announcement_draft.erb
@@ -0,0 +1,45 @@
+Hi everyone,
+
+I am happy to announce that Rails <%= versions.join(" and ") %> <%= versions.size > 1 ? "have" : "has" %> been released.
+
+<% if future_date %>
+If no regressions are found, expect the final release on <%= future_date.strftime("%A, %B %-d, %Y") %>.
+If you find one, please open an [issue on GitHub](https://github.com/rails/rails/issues/new)
+<%= "and mention me (@#{github_user}) on it, " unless github_user.empty? %>so that we can fix it before the final release.
+<% end %>
+<% versions.each do |version| %>
+
+## CHANGES since <%= version.previous %>
+
+To view the changes for each gem, please read the changelogs on GitHub:
+<% FRAMEWORKS.sort.each do |framework| %>
+<%= "* [#{FRAMEWORK_NAMES[framework]} CHANGELOG](https://github.com/rails/rails/blob/v#{version}/#{framework}/CHANGELOG.md)" %>
+
+<% end %>
+
+To see a summary of changes, please read the release on GitHub:
+
+<%= "[#{version} CHANGELOG](https://github.com/rails/rails/releases/tag/v#{version})" %>
+
+
+*Full listing*
+
+To see the full list of changes, [check out all the commits on
+GitHub](https://github.com/rails/rails/compare/v<%= "#{version.previous}...v#{version}" %>).
+<% end %>
+
+## SHA-256
+
+If you'd like to verify that your gem is the same as the one I've uploaded,
+please use these SHA-256 hashes.
+
+<% versions.each do |version| %>
+Here are the checksums for <%= version %>:
+
+```
+$ shasum -a 256 *-<%= version %>.gem
+<%= `shasum -a 256 *-#{version}.gem` %>
+```
+
+<% end %>
+As always, huge thanks to the many contributors who helped with this release.
diff --git a/ruby_version_check.rb b/ruby_version_check.rb
new file mode 100644
index 0000000000000..8b2a8c2383d90
--- /dev/null
+++ b/ruby_version_check.rb
@@ -0,0 +1,15 @@
+# frozen_string_literal: true
+
+if Gem::Version.new(RUBY_VERSION) < Gem::Version.new("2.7.0") && RUBY_ENGINE == "ruby"
+  desc = defined?(RUBY_DESCRIPTION) ? RUBY_DESCRIPTION : "ruby #{RUBY_VERSION} (#{RUBY_RELEASE_DATE})"
+  abort <<-end_message
+
+    Rails 7 requires Ruby 2.7.0 or newer.
+
+    You're running
+      #{desc}
+
+    Please upgrade to Ruby 2.7.0 or newer to continue.
+
+  end_message
+end
diff --git a/secrets.rb b/secrets.rb
new file mode 100644
index 0000000000000..54ba53c03b981
--- /dev/null
+++ b/secrets.rb
@@ -0,0 +1,108 @@
+# frozen_string_literal: true
+
+require "yaml"
+require "active_support/message_encryptor"
+
+module Rails
+  # Greatly inspired by Ara T. Howard's magnificent sekrets gem. 
+  class Secrets # :nodoc:
+    class MissingKeyError < RuntimeError
+      def initialize
+        super(<<-end_of_message.squish)
+          Missing encryption key to decrypt secrets with.
+          Ask your team for your master key and put it in ENV["RAILS_MASTER_KEY"]
+        end_of_message
+      end
+    end
+
+    @cipher = "aes-128-gcm"
+    @root = File # Wonky, but ensures `join` uses the current directory.
+
+    class << self
+      attr_writer :root
+
+      def parse(paths, env:)
+        paths.each_with_object(Hash.new) do |path, all_secrets|
+          require "erb"
+
+          source = ERB.new(preprocess(path)).result
+          secrets = YAML.respond_to?(:unsafe_load) ? YAML.unsafe_load(source) : YAML.load(source)
+          secrets ||= {}
+
+          all_secrets.merge!(secrets["shared"].deep_symbolize_keys) if secrets["shared"]
+          all_secrets.merge!(secrets[env].deep_symbolize_keys) if secrets[env]
+        end
+      end
+
+      def key
+        ENV["RAILS_MASTER_KEY"] || read_key_file || handle_missing_key
+      end
+
+      def encrypt(data)
+        encryptor.encrypt_and_sign(data)
+      end
+
+      def decrypt(data)
+        encryptor.decrypt_and_verify(data)
+      end
+
+      def read
+        decrypt(IO.binread(path))
+      end
+
+      def write(contents)
+        IO.binwrite("#{path}.tmp", encrypt(contents))
+        FileUtils.mv("#{path}.tmp", path)
+      end
+
+      def read_for_editing(&block)
+        writing(read, &block)
+      end
+
+      private
+        def handle_missing_key
+          raise MissingKeyError
+        end
+
+        def read_key_file
+          if File.exist?(key_path)
+            IO.binread(key_path).strip
+          end
+        end
+
+        def key_path
+          @root.join("config", "secrets.yml.key")
+        end
+
+        def path
+          @root.join("config", "secrets.yml.enc").to_s
+        end
+
+        def preprocess(path)
+          if path.end_with?(".enc")
+            decrypt(IO.binread(path))
+          else
+            IO.read(path)
+          end
+        end
+
+        def writing(contents)
+          tmp_file = "#{File.basename(path)}.#{Process.pid}"
+          tmp_path = File.join(Dir.tmpdir, tmp_file)
+          IO.binwrite(tmp_path, contents)
+
+          yield tmp_path
+
+          updated_contents = IO.binread(tmp_path)
+
+          write(updated_contents) if updated_contents != contents
+        ensure
+          FileUtils.rm(tmp_path) if File.exist?(tmp_path)
+        end
+
+        def encryptor
+          @encryptor ||= ActiveSupport::MessageEncryptor.new([ key ].pack("H*"), cipher: @cipher)
+        end
+    end
+  end
+end
diff --git a/source_annotation_extractor.rb b/source_annotation_extractor.rb
new file mode 100644
index 0000000000000..2859b2122eeea
--- /dev/null
+++ b/source_annotation_extractor.rb
@@ -0,0 +1,148 @@
+# frozen_string_literal: true
+
+module Rails
+  # Implements the logic behind <tt>Rails::Command::NotesCommand</tt>. See <tt>rails notes --help</tt> for usage information.
+  #
+  # Annotation objects are triplets <tt>:line</tt>, <tt>:tag</tt>, <tt>:text</tt> that
+  # represent the line where the annotation lives, its tag, and its text. Note
+  # the filename is not stored.
+  #
+  # Annotations are looked for in comments and modulus whitespace they have to
+  # start with the tag optionally followed by a colon. Everything up to the end
+  # of the line (or closing ERB comment tag) is considered to be their text.
+  class SourceAnnotationExtractor
+    class Annotation < Struct.new(:line, :tag, :text)
+      def self.directories
+        @@directories ||= %w(app config db lib test)
+      end
+
+      # Registers additional directories to be included
+      #   Rails::SourceAnnotationExtractor::Annotation.register_directories("spec", "another")
+      def self.register_directories(*dirs)
+        directories.push(*dirs)
+      end
+
+      def self.tags
+        @@tags ||= %w(OPTIMIZE FIXME TODO)
+      end
+
+      # Registers additional tags
+      #   Rails::SourceAnnotationExtractor::Annotation.register_tags("TESTME", "DEPRECATEME")
+      def self.register_tags(*additional_tags)
+        tags.push(*additional_tags)
+      end
+
+      def self.extensions
+        @@extensions ||= {}
+      end
+
+      # Registers new Annotations File Extensions
+      #   Rails::SourceAnnotationExtractor::Annotation.register_extensions("css", "scss", "sass", "less", "js") { |tag| /\/\/\s*(#{tag}):?\s*(.*)$/ }
+      def self.register_extensions(*exts, &block)
+        extensions[/\.(#{exts.join("|")})$/] = block
+      end
+
+      register_extensions("builder", "rb", "rake", "yml", "yaml", "ruby") { |tag| /#\s*(#{tag}):?\s*(.*)$/ }
+      register_extensions("css", "js") { |tag| /\/\/\s*(#{tag}):?\s*(.*)$/ }
+      register_extensions("erb") { |tag| /<%\s*#\s*(#{tag}):?\s*(.*?)\s*%>/ }
+
+      # Returns a representation of the annotation that looks like this:
+      #
+      #   [126] [TODO] This algorithm is simple and clearly correct, make it faster.
+      #
+      # If +options+ has a flag <tt>:tag</tt> the tag is shown as in the example above.
+      # Otherwise the string contains just line and text.
+      def to_s(options = {})
+        s = +"[#{line.to_s.rjust(options[:indent])}] "
+        s << "[#{tag}] " if options[:tag]
+        s << text
+      end
+    end
+
+    # Prints all annotations with tag +tag+ under the root directories +app+,
+    # +config+, +db+, +lib+, and +test+ (recursively).
+    #
+    # If +tag+ is <tt>nil</tt>, annotations with either default or registered tags are printed.
+    #
+    # Specific directories can be explicitly set using the <tt>:dirs</tt> key in +options+.
+    #
+    #   Rails::SourceAnnotationExtractor.enumerate 'TODO|FIXME', dirs: %w(app lib), tag: true
+    #
+    # If +options+ has a <tt>:tag</tt> flag, it will be passed to each annotation's +to_s+.
+    #
+    # See SourceAnnotationExtractor#find_in for a list of file extensions that will be taken into account.
+    #
+    # This class method is the single entry point for the <tt>rails notes</tt> command.
+    def self.enumerate(tag = nil, options = {})
+      tag ||= Annotation.tags.join("|")
+      extractor = new(tag)
+      dirs = options.delete(:dirs) || Annotation.directories
+      extractor.display(extractor.find(dirs), options)
+    end
+
+    attr_reader :tag
+
+    def initialize(tag)
+      @tag = tag
+    end
+
+    # Returns a hash that maps filenames under +dirs+ (recursively) to arrays
+    # with their annotations.
+    def find(dirs)
+      dirs.inject({}) { |h, dir| h.update(find_in(dir)) }
+    end
+
+    # Returns a hash that maps filenames under +dir+ (recursively) to arrays
+    # with their annotations. Files with extensions registered in
+    # <tt>Rails::SourceAnnotationExtractor::Annotation.extensions</tt> are
+    # taken into account. Only files with annotations are included.
+    def find_in(dir)
+      results = {}
+
+      Dir.glob("#{dir}/*") do |item|
+        next if File.basename(item).start_with?(".")
+
+        if File.directory?(item)
+          results.update(find_in(item))
+        else
+          extension = Annotation.extensions.detect do |regexp, _block|
+            regexp.match(item)
+          end
+
+          if extension
+            pattern = extension.last.call(tag)
+            results.update(extract_annotations_from(item, pattern)) if pattern
+          end
+        end
+      end
+
+      results
+    end
+
+    # If +file+ is the filename of a file that contains annotations this method returns
+    # a hash with a single entry that maps +file+ to an array of its annotations.
+    # Otherwise it returns an empty hash.
+    def extract_annotations_from(file, pattern)
+      lineno = 0
+      result = File.readlines(file, encoding: Encoding::BINARY).inject([]) do |list, line|
+        lineno += 1
+        next list unless line =~ pattern
+        list << Annotation.new(lineno, $1, $2)
+      end
+      result.empty? ? {} : { file => result }
+    end
+
+    # Prints the mapping from filenames to annotations in +results+ ordered by filename.
+    # The +options+ hash is passed to each annotation's +to_s+.
+    def display(results, options = {})
+      options[:indent] = results.flat_map { |f, a| a.map(&:line) }.max.to_s.size
+      results.keys.sort.each do |file|
+        puts "#{file}:"
+        results[file].each do |note|
+          puts "  * #{note.to_s(options)}"
+        end
+        puts
+      end
+    end
+  end
+end
diff --git a/tasks.rb b/tasks.rb
new file mode 100644
index 0000000000000..975479cc11377
--- /dev/null
+++ b/tasks.rb
@@ -0,0 +1,19 @@
+# frozen_string_literal: true
+
+require "rake"
+
+# Load Rails Rakefile extensions
+%w(
+  framework
+  log
+  middleware
+  misc
+  restart
+  tmp
+  yarn
+  zeitwerk
+).tap { |arr|
+  arr << "statistics" if Rake.application.current_scope.empty?
+}.each do |task|
+  load "rails/tasks/#{task}.rake"
+end
diff --git a/test b/test
new file mode 100644
index 0000000000000..c53377cc970f4
--- /dev/null
+++ b/test
@@ -0,0 +1,5 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+COMPONENT_ROOT = File.expand_path("..", __dir__)
+require_relative "../../tools/test"
diff --git a/test.rb b/test.rb
new file mode 100644
index 0000000000000..eab5d8ff37ad7
--- /dev/null
+++ b/test.rb
@@ -0,0 +1,18 @@
+# frozen_string_literal: true
+
+$: << File.expand_path("test", COMPONENT_ROOT)
+
+require "bundler/setup"
+
+require "rails/test_unit/runner"
+require "rails/test_unit/reporter"
+require "rails/test_unit/line_filtering"
+require "active_support"
+require "active_support/test_case"
+
+ActiveSupport::TestCase.extend Rails::LineFiltering
+Rails::TestUnitReporter.app_root = COMPONENT_ROOT
+Rails::TestUnitReporter.executable = "bin/test"
+
+Rails::TestUnit::Runner.parse_options(ARGV)
+Rails::TestUnit::Runner.run(ARGV)
diff --git a/test_common.rb b/test_common.rb
new file mode 100644
index 0000000000000..d5b92b5a26a19
--- /dev/null
+++ b/test_common.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: true
+
+if ENV["BUILDKITE"]
+  require "minitest-ci"
+
+  Minitest::Ci.report_dir = File.join(__dir__, "../test-reports/#{ENV['BUILDKITE_JOB_ID']}")
+end
diff --git a/test_help.rb b/test_help.rb
new file mode 100644
index 0000000000000..4e3ec184bec27
--- /dev/null
+++ b/test_help.rb
@@ -0,0 +1,50 @@
+# frozen_string_literal: true
+
+# Make double-sure the RAILS_ENV is not set to production,
+# so fixtures aren't loaded into that environment
+abort("Abort testing: Your Rails environment is running in production mode!") if Rails.env.production?
+
+require "active_support/test_case"
+require "action_controller"
+require "action_controller/test_case"
+require "action_dispatch/testing/integration"
+require "rails/generators/test_case"
+
+require "active_support/testing/autorun"
+
+if defined?(ActiveRecord::Base)
+  begin
+    ActiveRecord::Migration.maintain_test_schema!
+  rescue ActiveRecord::PendingMigrationError => e
+    puts e.to_s.strip
+    exit 1
+  end
+
+  ActiveSupport.on_load(:active_support_test_case) do
+    include ActiveRecord::TestDatabases
+    include ActiveRecord::TestFixtures
+
+    self.fixture_path = "#{Rails.root}/test/fixtures/"
+    self.file_fixture_path = fixture_path + "files"
+  end
+
+  ActiveSupport.on_load(:action_dispatch_integration_test) do
+    self.fixture_path = ActiveSupport::TestCase.fixture_path
+  end
+end
+
+# :enddoc:
+
+ActiveSupport.on_load(:action_controller_test_case) do
+  def before_setup # :nodoc:
+    @routes = Rails.application.routes
+    super
+  end
+end
+
+ActiveSupport.on_load(:action_dispatch_integration_test) do
+  def before_setup # :nodoc:
+    @routes = Rails.application.routes
+    super
+  end
+end
diff --git a/test_run.rb b/test_run.rb
new file mode 100644
index 0000000000000..c3ba53ea7acf2
--- /dev/null
+++ b/test_run.rb
@@ -0,0 +1,72 @@
+# frozen_string_literal: true
+
+# The MIT License (MIT)
+#
+# Copyright (c) 2014 Silvio Montanari
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+# This class based on https://github.com/smontanari/qunit-selenium, with a few tweaks to make it easier to read output.
+class TestRun
+  TestResult = Struct.new(:tests, :assertions, :duration, :raw_output)
+
+  ID_TESTRESULT = "qunit-testresult"
+  ID_TESTS = "qunit-tests"
+
+  def initialize(driver)
+    @qunit_testresult = driver[ID_TESTRESULT]
+    @qunit_tests = driver[ID_TESTS]
+  end
+
+  def completed?
+    @qunit_testresult.text =~ /Tests completed/
+  end
+
+  def result
+    assertions = { total: total_assertions, passed: passed_assertions, failed: failed_assertions }
+    tests = { total: total_tests, passed: pass_tests, failed: fail_tests }
+    TestResult.new(tests, assertions, duration, raw_output)
+  end
+
+  private
+    def raw_output
+      @qunit_tests.text
+    end
+
+    def duration
+      match = /Tests completed in (?<milliseconds>\d+) milliseconds/.match @qunit_testresult.text
+      match[:milliseconds].to_i / 1000
+    end
+
+    %w(total passed failed).each do |result|
+      define_method("#{result}_assertions".to_sym) do
+        @qunit_testresult.find_elements(:class, result).first.text.to_i
+      end
+    end
+
+    def total_tests
+      @qunit_tests.find_elements(:css, "##{ID_TESTS} > *").count
+    end
+
+    %w(pass fail).each do |result|
+      define_method("#{result}_tests".to_sym) do
+        @qunit_tests.find_elements(:css, "##{ID_TESTS} > .#{result}").count
+      end
+    end
+end
diff --git a/version.rb b/version.rb
index 06d6945f020fd..e38eebaadb34f 100644
--- a/version.rb
+++ b/version.rb
@@ -1,17 +1,10 @@
 # frozen_string_literal: true
 
-module Rails
-  # Returns the currently loaded version of Rails as a <tt>Gem::Version</tt>.
-  def self.gem_version
-    Gem::Version.new VERSION::STRING
-  end
+require_relative "gem_version"
 
-  module VERSION
-    MAJOR = 7
-    MINOR = 1
-    TINY  = 0
-    PRE   = "alpha"
-
-    STRING = [MAJOR, MINOR, TINY, PRE].compact.join(".")
+module Rails
+  # Returns the currently loaded version of Rails as a string.
+  def self.version
+    VERSION::STRING
   end
 end
diff --git a/welcome_controller.rb b/welcome_controller.rb
new file mode 100644
index 0000000000000..986c7c0a74824
--- /dev/null
+++ b/welcome_controller.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: true
+
+require "rails/application_controller"
+
+class Rails::WelcomeController < Rails::ApplicationController # :nodoc:
+  skip_forgery_protection
+  layout false
+
+  def index
+  end
+end
